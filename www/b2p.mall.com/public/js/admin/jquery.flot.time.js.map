{"version":3,"sources":["jquery.flot.time.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.flot.time.js","sourcesContent":["/* Pretty handling of time axes.\r\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\r\nLicensed under the MIT license.\r\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\r\nAPI.txt for details.\r\n*/\r\n\r\n(function($) {\r\n\r\n    var options = {\r\n        xaxis: {\r\n            timezone: null,     // \"browser\" for local to the client or timezone for timezone-js\r\n            timeformat: null,   // format string to use\r\n            twelveHourClock: false, // 12 or 24 time in time mode\r\n            monthNames: null    // list of names of months\r\n        }\r\n    };\r\n\r\n    // round to nearby lower multiple of base\r\n\r\n    function floorInBase(n, base) {\r\n        return base * Math.floor(n / base);\r\n    }\r\n\r\n    // Returns a string with the date d formatted according to fmt.\r\n    // A subset of the Open Group's strftime format is supported.\r\n\r\n    function formatDate(d, fmt, monthNames, dayNames) {\r\n\r\n        if (typeof d.strftime == \"function\") {\r\n            return d.strftime(fmt);\r\n        }\r\n\r\n        var leftPad = function(n, pad) {\r\n            n = \"\" + n;\r\n            pad = \"\" + (pad == null ? \"0\" : pad);\r\n            return n.length == 1 ? pad + n : n;\r\n        };\r\n\r\n        var r = [];\r\n        var escape = false;\r\n        var hours = d.getHours();\r\n        var isAM = hours < 12;\r\n\r\n        if (monthNames == null) {\r\n            monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\r\n        }\r\n\r\n        if (dayNames == null) {\r\n            dayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\r\n        }\r\n\r\n        var hours12;\r\n\r\n        if (hours > 12) {\r\n            hours12 = hours - 12;\r\n        } else if (hours == 0) {\r\n            hours12 = 12;\r\n        } else {\r\n            hours12 = hours;\r\n        }\r\n\r\n        for (var i = 0; i < fmt.length; ++i) {\r\n\r\n            var c = fmt.charAt(i);\r\n\r\n            if (escape) {\r\n                switch (c) {\r\n                    case 'a': c = \"\" + dayNames[d.getDay()]; break;\r\n                    case 'b': c = \"\" + monthNames[d.getMonth()]; break;\r\n                    case 'd': c = leftPad(d.getDate()); break;\r\n                    case 'e': c = leftPad(d.getDate(), \" \"); break;\r\n                    case 'h':   // For back-compat with 0.7; remove in 1.0\r\n                    case 'H': c = leftPad(hours); break;\r\n                    case 'I': c = leftPad(hours12); break;\r\n                    case 'l': c = leftPad(hours12, \" \"); break;\r\n                    case 'm': c = leftPad(d.getMonth() + 1); break;\r\n                    case 'M': c = leftPad(d.getMinutes()); break;\r\n                    // quarters not in Open Group's strftime specification\r\n                    case 'q':\r\n                        c = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\r\n                    case 'S': c = leftPad(d.getSeconds()); break;\r\n                    case 'y': c = leftPad(d.getFullYear() % 100); break;\r\n                    case 'Y': c = \"\" + d.getFullYear(); break;\r\n                    case 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\r\n                    case 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\r\n                    case 'w': c = \"\" + d.getDay(); break;\r\n                }\r\n                r.push(c);\r\n                escape = false;\r\n            } else {\r\n                if (c == \"%\") {\r\n                    escape = true;\r\n                } else {\r\n                    r.push(c);\r\n                }\r\n            }\r\n        }\r\n\r\n        return r.join(\"\");\r\n    }\r\n\r\n    // To have a consistent view of time-based data independent of which time\r\n    // zone the client happens to be in we need a date-like object independent\r\n    // of time zones.  This is done through a wrapper that only calls the UTC\r\n    // versions of the accessor methods.\r\n\r\n    function makeUtcWrapper(d) {\r\n\r\n        function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\r\n            sourceObj[sourceMethod] = function() {\r\n                return targetObj[targetMethod].apply(targetObj, arguments);\r\n            };\r\n        };\r\n\r\n        var utc = {\r\n            date: d\r\n        };\r\n\r\n        // support strftime, if found\r\n\r\n        if (d.strftime != undefined) {\r\n            addProxyMethod(utc, \"strftime\", d, \"strftime\");\r\n        }\r\n\r\n        addProxyMethod(utc, \"getTime\", d, \"getTime\");\r\n        addProxyMethod(utc, \"setTime\", d, \"setTime\");\r\n\r\n        var props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\r\n\r\n        for (var p = 0; p < props.length; p++) {\r\n            addProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\r\n            addProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\r\n        }\r\n\r\n        return utc;\r\n    };\r\n\r\n    // select time zone strategy.  This returns a date-like object tied to the\r\n    // desired timezone\r\n\r\n    function dateGenerator(ts, opts) {\r\n        if (opts.timezone == \"browser\") {\r\n            return new Date(ts);\r\n        } else if (!opts.timezone || opts.timezone == \"utc\") {\r\n            return makeUtcWrapper(new Date(ts));\r\n        } else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\r\n            var d = new timezoneJS.Date();\r\n            // timezone-js is fickle, so be sure to set the time zone before\r\n            // setting the time.\r\n            d.setTimezone(opts.timezone);\r\n            d.setTime(ts);\r\n            return d;\r\n        } else {\r\n            return makeUtcWrapper(new Date(ts));\r\n        }\r\n    }\r\n    \r\n    // map of app. size of time units in milliseconds\r\n\r\n    var timeUnitSize = {\r\n        \"second\": 1000,\r\n        \"minute\": 60 * 1000,\r\n        \"hour\": 60 * 60 * 1000,\r\n        \"day\": 24 * 60 * 60 * 1000,\r\n        \"month\": 30 * 24 * 60 * 60 * 1000,\r\n        \"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\r\n        \"year\": 365.2425 * 24 * 60 * 60 * 1000\r\n    };\r\n\r\n    // the allowed tick sizes, after 1 year we use\r\n    // an integer algorithm\r\n\r\n    var baseSpec = [\r\n        [1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\r\n        [30, \"second\"], \r\n        [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\r\n        [30, \"minute\"], \r\n        [1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\r\n        [8, \"hour\"], [12, \"hour\"],\r\n        [1, \"day\"], [2, \"day\"], [3, \"day\"],\r\n        [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\r\n        [2, \"month\"]\r\n    ];\r\n\r\n    // we don't know which variant(s) we'll need yet, but generating both is\r\n    // cheap\r\n\r\n    var specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\r\n        [1, \"year\"]]);\r\n    var specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\r\n        [1, \"year\"]]);\r\n\r\n    function init(plot) {\r\n        plot.hooks.processOptions.push(function (plot, options) {\r\n            $.each(plot.getAxes(), function(axisName, axis) {\r\n\r\n                var opts = axis.options;\r\n\r\n                if (opts.mode == \"time\") {\r\n                    axis.tickGenerator = function(axis) {\r\n\r\n                        var ticks = [];\r\n                        var d = dateGenerator(axis.min, opts);\r\n                        var minSize = 0;\r\n\r\n                        // make quarter use a possibility if quarters are\r\n                        // mentioned in either of these options\r\n\r\n                        var spec = (opts.tickSize && opts.tickSize[1] ===\r\n                            \"quarter\") ||\r\n                            (opts.minTickSize && opts.minTickSize[1] ===\r\n                            \"quarter\") ? specQuarters : specMonths;\r\n\r\n                        if (opts.minTickSize != null) {\r\n                            if (typeof opts.tickSize == \"number\") {\r\n                                minSize = opts.tickSize;\r\n                            } else {\r\n                                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\r\n                            }\r\n                        }\r\n\r\n                        for (var i = 0; i < spec.length - 1; ++i) {\r\n                            if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\r\n                                              + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\r\n                                && spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var size = spec[i][0];\r\n                        var unit = spec[i][1];\r\n\r\n                        // special-case the possibility of several years\r\n\r\n                        if (unit == \"year\") {\r\n\r\n                            // if given a minTickSize in years, just use it,\r\n                            // ensuring that it's an integer\r\n\r\n                            if (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\r\n                                size = Math.floor(opts.minTickSize[0]);\r\n                            } else {\r\n\r\n                                var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\r\n                                var norm = (axis.delta / timeUnitSize.year) / magn;\r\n\r\n                                if (norm < 1.5) {\r\n                                    size = 1;\r\n                                } else if (norm < 3) {\r\n                                    size = 2;\r\n                                } else if (norm < 7.5) {\r\n                                    size = 5;\r\n                                } else {\r\n                                    size = 10;\r\n                                }\r\n\r\n                                size *= magn;\r\n                            }\r\n\r\n                            // minimum size for years is 1\r\n\r\n                            if (size < 1) {\r\n                                size = 1;\r\n                            }\r\n                        }\r\n\r\n                        axis.tickSize = opts.tickSize || [size, unit];\r\n                        var tickSize = axis.tickSize[0];\r\n                        unit = axis.tickSize[1];\r\n\r\n                        var step = tickSize * timeUnitSize[unit];\r\n\r\n                        if (unit == \"second\") {\r\n                            d.setSeconds(floorInBase(d.getSeconds(), tickSize));\r\n                        } else if (unit == \"minute\") {\r\n                            d.setMinutes(floorInBase(d.getMinutes(), tickSize));\r\n                        } else if (unit == \"hour\") {\r\n                            d.setHours(floorInBase(d.getHours(), tickSize));\r\n                        } else if (unit == \"month\") {\r\n                            d.setMonth(floorInBase(d.getMonth(), tickSize));\r\n                        } else if (unit == \"quarter\") {\r\n                            d.setMonth(3 * floorInBase(d.getMonth() / 3,\r\n                                tickSize));\r\n                        } else if (unit == \"year\") {\r\n                            d.setFullYear(floorInBase(d.getFullYear(), tickSize));\r\n                        }\r\n\r\n                        // reset smaller components\r\n\r\n                        d.setMilliseconds(0);\r\n\r\n                        if (step >= timeUnitSize.minute) {\r\n                            d.setSeconds(0);\r\n                        }\r\n                        if (step >= timeUnitSize.hour) {\r\n                            d.setMinutes(0);\r\n                        }\r\n                        if (step >= timeUnitSize.day) {\r\n                            d.setHours(0);\r\n                        }\r\n                        if (step >= timeUnitSize.day * 4) {\r\n                            d.setDate(1);\r\n                        }\r\n                        if (step >= timeUnitSize.month * 2) {\r\n                            d.setMonth(floorInBase(d.getMonth(), 3));\r\n                        }\r\n                        if (step >= timeUnitSize.quarter * 2) {\r\n                            d.setMonth(floorInBase(d.getMonth(), 6));\r\n                        }\r\n                        if (step >= timeUnitSize.year) {\r\n                            d.setMonth(0);\r\n                        }\r\n\r\n                        var carry = 0;\r\n                        var v = Number.NaN;\r\n                        var prev;\r\n\r\n                        do {\r\n\r\n                            prev = v;\r\n                            v = d.getTime();\r\n                            ticks.push(v);\r\n\r\n                            if (unit == \"month\" || unit == \"quarter\") {\r\n                                if (tickSize < 1) {\r\n\r\n                                    // a bit complicated - we'll divide the\r\n                                    // month/quarter up but we need to take\r\n                                    // care of fractions so we don't end up in\r\n                                    // the middle of a day\r\n\r\n                                    d.setDate(1);\r\n                                    var start = d.getTime();\r\n                                    d.setMonth(d.getMonth() +\r\n                                        (unit == \"quarter\" ? 3 : 1));\r\n                                    var end = d.getTime();\r\n                                    d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\r\n                                    carry = d.getHours();\r\n                                    d.setHours(0);\r\n                                } else {\r\n                                    d.setMonth(d.getMonth() +\r\n                                        tickSize * (unit == \"quarter\" ? 3 : 1));\r\n                                }\r\n                            } else if (unit == \"year\") {\r\n                                d.setFullYear(d.getFullYear() + tickSize);\r\n                            } else {\r\n                                d.setTime(v + step);\r\n                            }\r\n                        } while (v < axis.max && v != prev);\r\n\r\n                        return ticks;\r\n                    };\r\n\r\n                    axis.tickFormatter = function (v, axis) {\r\n\r\n                        var d = dateGenerator(v, axis.options);\r\n\r\n                        // first check global format\r\n\r\n                        if (opts.timeformat != null) {\r\n                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\r\n                        }\r\n\r\n                        // possibly use quarters if quarters are mentioned in\r\n                        // any of these places\r\n\r\n                        var useQuarters = (axis.options.tickSize &&\r\n                                axis.options.tickSize[1] == \"quarter\") ||\r\n                            (axis.options.minTickSize &&\r\n                                axis.options.minTickSize[1] == \"quarter\");\r\n\r\n                        var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\r\n                        var span = axis.max - axis.min;\r\n                        var suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\r\n                        var hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\r\n                        var fmt;\r\n\r\n                        if (t < timeUnitSize.minute) {\r\n                            fmt = hourCode + \":%M:%S\" + suffix;\r\n                        } else if (t < timeUnitSize.day) {\r\n                            if (span < 2 * timeUnitSize.day) {\r\n                                fmt = hourCode + \":%M\" + suffix;\r\n                            } else {\r\n                                fmt = \"%b %d \" + hourCode + \":%M\" + suffix;\r\n                            }\r\n                        } else if (t < timeUnitSize.month) {\r\n                            fmt = \"%b %d\";\r\n                        } else if ((useQuarters && t < timeUnitSize.quarter) ||\r\n                            (!useQuarters && t < timeUnitSize.year)) {\r\n                            if (span < timeUnitSize.year) {\r\n                                fmt = \"%b\";\r\n                            } else {\r\n                                fmt = \"%b %Y\";\r\n                            }\r\n                        } else if (useQuarters && t < timeUnitSize.year) {\r\n                            if (span < timeUnitSize.year) {\r\n                                fmt = \"Q%q\";\r\n                            } else {\r\n                                fmt = \"Q%q %Y\";\r\n                            }\r\n                        } else {\r\n                            fmt = \"%Y\";\r\n                        }\r\n\r\n                        var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\r\n\r\n                        return rt;\r\n                    };\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    $.plot.plugins.push({\r\n        init: init,\r\n        options: options,\r\n        name: 'time',\r\n        version: '1.0'\r\n    });\r\n\r\n    // Time-axis support used to be in Flot core, which exposed the\r\n    // formatDate function on the plot object.  Various plugins depend\r\n    // on the function, so we need to re-expose it here.\r\n\r\n    $.plot.formatDate = formatDate;\r\n    $.plot.dateGenerator = dateGenerator;\r\n\r\n})(jQuery);"],"sourceRoot":"/source/"}