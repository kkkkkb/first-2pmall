{"version":3,"sources":["additional-methods.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"additional-methods.js","sourcesContent":["/*!\r\n * jQuery Validation Plugin v1.15.0\r\n *\r\n * http://jqueryvalidation.org/\r\n *\r\n * Copyright (c) 2016 Jörn Zaefferer\r\n * Released under the MIT license\r\n */\r\n(function( factory ) {\r\n\tif ( typeof define === \"function\" && define.amd ) {\r\n\t\tdefine( [\"jquery\", \"./jquery.validate\"], factory );\r\n\t} else if (typeof module === \"object\" && module.exports) {\r\n\t\tmodule.exports = factory( require( \"jquery\" ) );\r\n\t} else {\r\n\t\tfactory( jQuery );\r\n\t}\r\n}(function( $ ) {\r\n\r\n( function() {\r\n\r\n\tfunction stripHtml( value ) {\r\n\r\n\t\t// Remove html tags and space chars\r\n\t\treturn value.replace( /<.[^<>]*?>/g, \" \" ).replace( /&nbsp;|&#160;/gi, \" \" )\r\n\r\n\t\t// Remove punctuation\r\n\t\t.replace( /[.(),;:!?%#$'\\\"_+=\\/\\-“”’]*/g, \"\" );\r\n\t}\r\n\r\n\t$.validator.addMethod( \"maxWords\", function( value, element, params ) {\r\n\t\treturn this.optional( element ) || stripHtml( value ).match( /\\b\\w+\\b/g ).length <= params;\r\n\t}, $.validator.format( \"Please enter {0} words or less.\" ) );\r\n\r\n\t$.validator.addMethod( \"minWords\", function( value, element, params ) {\r\n\t\treturn this.optional( element ) || stripHtml( value ).match( /\\b\\w+\\b/g ).length >= params;\r\n\t}, $.validator.format( \"Please enter at least {0} words.\" ) );\r\n\r\n\t$.validator.addMethod( \"rangeWords\", function( value, element, params ) {\r\n\t\tvar valueStripped = stripHtml( value ),\r\n\t\t\tregex = /\\b\\w+\\b/g;\r\n\t\treturn this.optional( element ) || valueStripped.match( regex ).length >= params[ 0 ] && valueStripped.match( regex ).length <= params[ 1 ];\r\n\t}, $.validator.format( \"Please enter between {0} and {1} words.\" ) );\r\n\r\n}() );\r\n\r\n// Accept a value from a file input based on a required mimetype\r\n$.validator.addMethod( \"accept\", function( value, element, param ) {\r\n\r\n\t// Split mime on commas in case we have multiple types we can accept\r\n\tvar typeParam = typeof param === \"string\" ? param.replace( /\\s/g, \"\" ) : \"image/*\",\r\n\toptionalValue = this.optional( element ),\r\n\ti, file, regex;\r\n\r\n\t// Element is optional\r\n\tif ( optionalValue ) {\r\n\t\treturn optionalValue;\r\n\t}\r\n\r\n\tif ( $( element ).attr( \"type\" ) === \"file\" ) {\r\n\r\n\t\t// Escape string to be used in the regex\r\n\t\t// see: http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\r\n\t\t// Escape also \"/*\" as \"/.*\" as a wildcard\r\n\t\ttypeParam = typeParam.replace( /[\\-\\[\\]\\/\\{\\}\\(\\)\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\" ).replace( /,/g, \"|\" ).replace( \"\\/*\", \"/.*\" );\r\n\r\n\t\t// Check if the element has a FileList before checking each file\r\n\t\tif ( element.files && element.files.length ) {\r\n\t\t\tregex = new RegExp( \".?(\" + typeParam + \")$\", \"i\" );\r\n\t\t\tfor ( i = 0; i < element.files.length; i++ ) {\r\n\t\t\t\tfile = element.files[ i ];\r\n\r\n\t\t\t\t// Grab the mimetype from the loaded file, verify it matches\r\n\t\t\t\tif ( !file.type.match( regex ) ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Either return true because we've validated each file, or because the\r\n\t// browser does not support element.files and the FileList feature\r\n\treturn true;\r\n}, $.validator.format( \"Please enter a value with a valid mimetype.\" ) );\r\n\r\n$.validator.addMethod( \"alphanumeric\", function( value, element ) {\r\n\treturn this.optional( element ) || /^\\w+$/i.test( value );\r\n}, \"Letters, numbers, and underscores only please\" );\r\n\r\n/*\r\n * Dutch bank account numbers (not 'giro' numbers) have 9 digits\r\n * and pass the '11 check'.\r\n * We accept the notation with spaces, as that is common.\r\n * acceptable: 123456789 or 12 34 56 789\r\n */\r\n$.validator.addMethod( \"bankaccountNL\", function( value, element ) {\r\n\tif ( this.optional( element ) ) {\r\n\t\treturn true;\r\n\t}\r\n\tif ( !( /^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test( value ) ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Now '11 check'\r\n\tvar account = value.replace( / /g, \"\" ), // Remove spaces\r\n\t\tsum = 0,\r\n\t\tlen = account.length,\r\n\t\tpos, factor, digit;\r\n\tfor ( pos = 0; pos < len; pos++ ) {\r\n\t\tfactor = len - pos;\r\n\t\tdigit = account.substring( pos, pos + 1 );\r\n\t\tsum = sum + factor * digit;\r\n\t}\r\n\treturn sum % 11 === 0;\r\n}, \"Please specify a valid bank account number\" );\r\n\r\n$.validator.addMethod( \"bankorgiroaccountNL\", function( value, element ) {\r\n\treturn this.optional( element ) ||\r\n\t\t\t( $.validator.methods.bankaccountNL.call( this, value, element ) ) ||\r\n\t\t\t( $.validator.methods.giroaccountNL.call( this, value, element ) );\r\n}, \"Please specify a valid bank or giro account number\" );\r\n\r\n/**\r\n * BIC is the business identifier code (ISO 9362). This BIC check is not a guarantee for authenticity.\r\n *\r\n * BIC pattern: BBBBCCLLbbb (8 or 11 characters long; bbb is optional)\r\n *\r\n * Validation is case-insensitive. Please make sure to normalize input yourself.\r\n *\r\n * BIC definition in detail:\r\n * - First 4 characters - bank code (only letters)\r\n * - Next 2 characters - ISO 3166-1 alpha-2 country code (only letters)\r\n * - Next 2 characters - location code (letters and digits)\r\n *   a. shall not start with '0' or '1'\r\n *   b. second character must be a letter ('O' is not allowed) or digit ('0' for test (therefore not allowed), '1' denoting passive participant, '2' typically reverse-billing)\r\n * - Last 3 characters - branch code, optional (shall not start with 'X' except in case of 'XXX' for primary office) (letters and digits)\r\n */\r\n$.validator.addMethod( \"bic\", function( value, element ) {\r\n    return this.optional( element ) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test( value.toUpperCase() );\r\n}, \"Please specify a valid BIC code\" );\r\n\r\n/*\r\n * Código de identificación fiscal ( CIF ) is the tax identification code for Spanish legal entities\r\n * Further rules can be found in Spanish on http://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal\r\n */\r\n$.validator.addMethod( \"cifES\", function( value ) {\r\n\t\"use strict\";\r\n\r\n\tvar num = [],\r\n\t\tcontrolDigit, sum, i, count, tmp, secondDigit;\r\n\r\n\tvalue = value.toUpperCase();\r\n\r\n\t// Quick format test\r\n\tif ( !value.match( \"((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)\" ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor ( i = 0; i < 9; i++ ) {\r\n\t\tnum[ i ] = parseInt( value.charAt( i ), 10 );\r\n\t}\r\n\r\n\t// Algorithm for checking CIF codes\r\n\tsum = num[ 2 ] + num[ 4 ] + num[ 6 ];\r\n\tfor ( count = 1; count < 8; count += 2 ) {\r\n\t\ttmp = ( 2 * num[ count ] ).toString();\r\n\t\tsecondDigit = tmp.charAt( 1 );\r\n\r\n\t\tsum += parseInt( tmp.charAt( 0 ), 10 ) + ( secondDigit === \"\" ? 0 : parseInt( secondDigit, 10 ) );\r\n\t}\r\n\r\n\t/* The first (position 1) is a letter following the following criteria:\r\n\t *\tA. Corporations\r\n\t *\tB. LLCs\r\n\t *\tC. General partnerships\r\n\t *\tD. Companies limited partnerships\r\n\t *\tE. Communities of goods\r\n\t *\tF. Cooperative Societies\r\n\t *\tG. Associations\r\n\t *\tH. Communities of homeowners in horizontal property regime\r\n\t *\tJ. Civil Societies\r\n\t *\tK. Old format\r\n\t *\tL. Old format\r\n\t *\tM. Old format\r\n\t *\tN. Nonresident entities\r\n\t *\tP. Local authorities\r\n\t *\tQ. Autonomous bodies, state or not, and the like, and congregations and religious institutions\r\n\t *\tR. Congregations and religious institutions (since 2008 ORDER EHA/451/2008)\r\n\t *\tS. Organs of State Administration and regions\r\n\t *\tV. Agrarian Transformation\r\n\t *\tW. Permanent establishments of non-resident in Spain\r\n\t */\r\n\tif ( /^[ABCDEFGHJNPQRSUVW]{1}/.test( value ) ) {\r\n\t\tsum += \"\";\r\n\t\tcontrolDigit = 10 - parseInt( sum.charAt( sum.length - 1 ), 10 );\r\n\t\tvalue += controlDigit;\r\n\t\treturn ( num[ 8 ].toString() === String.fromCharCode( 64 + controlDigit ) || num[ 8 ].toString() === value.charAt( value.length - 1 ) );\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}, \"Please specify a valid CIF number.\" );\r\n\r\n/*\r\n * Brazillian CPF number (Cadastrado de Pessoas Físicas) is the equivalent of a Brazilian tax registration number.\r\n * CPF numbers have 11 digits in total: 9 numbers followed by 2 check numbers that are being used for validation.\r\n */\r\n$.validator.addMethod( \"cpfBR\", function( value ) {\r\n\r\n\t// Removing special characters from value\r\n\tvalue = value.replace( /([~!@#$%^&*()_+=`{}\\[\\]\\-|\\\\:;'<>,.\\/? ])+/g, \"\" );\r\n\r\n\t// Checking value to have 11 digits only\r\n\tif ( value.length !== 11 ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar sum = 0,\r\n\t\tfirstCN, secondCN, checkResult, i;\r\n\r\n\tfirstCN = parseInt( value.substring( 9, 10 ), 10 );\r\n\tsecondCN = parseInt( value.substring( 10, 11 ), 10 );\r\n\r\n\tcheckResult = function( sum, cn ) {\r\n\t\tvar result = ( sum * 10 ) % 11;\r\n\t\tif ( ( result === 10 ) || ( result === 11 ) ) {\r\n\t\t\tresult = 0;\r\n\t\t}\r\n\t\treturn ( result === cn );\r\n\t};\r\n\r\n\t// Checking for dump data\r\n\tif ( value === \"\" ||\r\n\t\tvalue === \"00000000000\" ||\r\n\t\tvalue === \"11111111111\" ||\r\n\t\tvalue === \"22222222222\" ||\r\n\t\tvalue === \"33333333333\" ||\r\n\t\tvalue === \"44444444444\" ||\r\n\t\tvalue === \"55555555555\" ||\r\n\t\tvalue === \"66666666666\" ||\r\n\t\tvalue === \"77777777777\" ||\r\n\t\tvalue === \"88888888888\" ||\r\n\t\tvalue === \"99999999999\"\r\n\t) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Step 1 - using first Check Number:\r\n\tfor ( i = 1; i <= 9; i++ ) {\r\n\t\tsum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 11 - i );\r\n\t}\r\n\r\n\t// If first Check Number (CN) is valid, move to Step 2 - using second Check Number:\r\n\tif ( checkResult( sum, firstCN ) ) {\r\n\t\tsum = 0;\r\n\t\tfor ( i = 1; i <= 10; i++ ) {\r\n\t\t\tsum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 12 - i );\r\n\t\t}\r\n\t\treturn checkResult( sum, secondCN );\r\n\t}\r\n\treturn false;\r\n\r\n}, \"Please specify a valid CPF number\" );\r\n\r\n// http://jqueryvalidation.org/creditcard-method/\r\n// based on http://en.wikipedia.org/wiki/Luhn_algorithm\r\n$.validator.addMethod( \"creditcard\", function( value, element ) {\r\n\tif ( this.optional( element ) ) {\r\n\t\treturn \"dependency-mismatch\";\r\n\t}\r\n\r\n\t// Accept only spaces, digits and dashes\r\n\tif ( /[^0-9 \\-]+/.test( value ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar nCheck = 0,\r\n\t\tnDigit = 0,\r\n\t\tbEven = false,\r\n\t\tn, cDigit;\r\n\r\n\tvalue = value.replace( /\\D/g, \"\" );\r\n\r\n\t// Basing min and max length on\r\n\t// http://developer.ean.com/general_info/Valid_Credit_Card_Types\r\n\tif ( value.length < 13 || value.length > 19 ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor ( n = value.length - 1; n >= 0; n-- ) {\r\n\t\tcDigit = value.charAt( n );\r\n\t\tnDigit = parseInt( cDigit, 10 );\r\n\t\tif ( bEven ) {\r\n\t\t\tif ( ( nDigit *= 2 ) > 9 ) {\r\n\t\t\t\tnDigit -= 9;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnCheck += nDigit;\r\n\t\tbEven = !bEven;\r\n\t}\r\n\r\n\treturn ( nCheck % 10 ) === 0;\r\n}, \"Please enter a valid credit card number.\" );\r\n\r\n/* NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator\r\n * Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0\r\n * Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)\r\n */\r\n$.validator.addMethod( \"creditcardtypes\", function( value, element, param ) {\r\n\tif ( /[^0-9\\-]+/.test( value ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvalue = value.replace( /\\D/g, \"\" );\r\n\r\n\tvar validTypes = 0x0000;\r\n\r\n\tif ( param.mastercard ) {\r\n\t\tvalidTypes |= 0x0001;\r\n\t}\r\n\tif ( param.visa ) {\r\n\t\tvalidTypes |= 0x0002;\r\n\t}\r\n\tif ( param.amex ) {\r\n\t\tvalidTypes |= 0x0004;\r\n\t}\r\n\tif ( param.dinersclub ) {\r\n\t\tvalidTypes |= 0x0008;\r\n\t}\r\n\tif ( param.enroute ) {\r\n\t\tvalidTypes |= 0x0010;\r\n\t}\r\n\tif ( param.discover ) {\r\n\t\tvalidTypes |= 0x0020;\r\n\t}\r\n\tif ( param.jcb ) {\r\n\t\tvalidTypes |= 0x0040;\r\n\t}\r\n\tif ( param.unknown ) {\r\n\t\tvalidTypes |= 0x0080;\r\n\t}\r\n\tif ( param.all ) {\r\n\t\tvalidTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;\r\n\t}\r\n\tif ( validTypes & 0x0001 && /^(5[12345])/.test( value ) ) { // Mastercard\r\n\t\treturn value.length === 16;\r\n\t}\r\n\tif ( validTypes & 0x0002 && /^(4)/.test( value ) ) { // Visa\r\n\t\treturn value.length === 16;\r\n\t}\r\n\tif ( validTypes & 0x0004 && /^(3[47])/.test( value ) ) { // Amex\r\n\t\treturn value.length === 15;\r\n\t}\r\n\tif ( validTypes & 0x0008 && /^(3(0[012345]|[68]))/.test( value ) ) { // Dinersclub\r\n\t\treturn value.length === 14;\r\n\t}\r\n\tif ( validTypes & 0x0010 && /^(2(014|149))/.test( value ) ) { // Enroute\r\n\t\treturn value.length === 15;\r\n\t}\r\n\tif ( validTypes & 0x0020 && /^(6011)/.test( value ) ) { // Discover\r\n\t\treturn value.length === 16;\r\n\t}\r\n\tif ( validTypes & 0x0040 && /^(3)/.test( value ) ) { // Jcb\r\n\t\treturn value.length === 16;\r\n\t}\r\n\tif ( validTypes & 0x0040 && /^(2131|1800)/.test( value ) ) { // Jcb\r\n\t\treturn value.length === 15;\r\n\t}\r\n\tif ( validTypes & 0x0080 ) { // Unknown\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}, \"Please enter a valid credit card number.\" );\r\n\r\n/**\r\n * Validates currencies with any given symbols by @jameslouiz\r\n * Symbols can be optional or required. Symbols required by default\r\n *\r\n * Usage examples:\r\n *  currency: [\"£\", false] - Use false for soft currency validation\r\n *  currency: [\"$\", false]\r\n *  currency: [\"RM\", false] - also works with text based symbols such as \"RM\" - Malaysia Ringgit etc\r\n *\r\n *  <input class=\"currencyInput\" name=\"currencyInput\">\r\n *\r\n * Soft symbol checking\r\n *  currencyInput: {\r\n *     currency: [\"$\", false]\r\n *  }\r\n *\r\n * Strict symbol checking (default)\r\n *  currencyInput: {\r\n *     currency: \"$\"\r\n *     //OR\r\n *     currency: [\"$\", true]\r\n *  }\r\n *\r\n * Multiple Symbols\r\n *  currencyInput: {\r\n *     currency: \"$,£,¢\"\r\n *  }\r\n */\r\n$.validator.addMethod( \"currency\", function( value, element, param ) {\r\n    var isParamString = typeof param === \"string\",\r\n        symbol = isParamString ? param : param[ 0 ],\r\n        soft = isParamString ? true : param[ 1 ],\r\n        regex;\r\n\r\n    symbol = symbol.replace( /,/g, \"\" );\r\n    symbol = soft ? symbol + \"]\" : symbol + \"]?\";\r\n    regex = \"^[\" + symbol + \"([1-9]{1}[0-9]{0,2}(\\\\,[0-9]{3})*(\\\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\\\.[0-9]{0,2})?|0(\\\\.[0-9]{0,2})?|(\\\\.[0-9]{1,2})?)$\";\r\n    regex = new RegExp( regex );\r\n    return this.optional( element ) || regex.test( value );\r\n\r\n}, \"Please specify a valid currency\" );\r\n\r\n$.validator.addMethod( \"dateFA\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[1-4]\\d{3}\\/((0?[1-6]\\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\\/(30|([1-2][0-9])|(0?[1-9]))))$/.test( value );\r\n}, $.validator.messages.date );\r\n\r\n/**\r\n * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.\r\n *\r\n * @example $.validator.methods.date(\"01/01/1900\")\r\n * @result true\r\n *\r\n * @example $.validator.methods.date(\"01/13/1990\")\r\n * @result false\r\n *\r\n * @example $.validator.methods.date(\"01.01.1900\")\r\n * @result false\r\n *\r\n * @example <input name=\"pippo\" class=\"{dateITA:true}\" />\r\n * @desc Declares an optional input element whose value must be a valid date.\r\n *\r\n * @name $.validator.methods.dateITA\r\n * @type Boolean\r\n * @cat Plugins/Validate/Methods\r\n */\r\n$.validator.addMethod( \"dateITA\", function( value, element ) {\r\n\tvar check = false,\r\n\t\tre = /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\r\n\t\tadata, gg, mm, aaaa, xdata;\r\n\tif ( re.test( value ) ) {\r\n\t\tadata = value.split( \"/\" );\r\n\t\tgg = parseInt( adata[ 0 ], 10 );\r\n\t\tmm = parseInt( adata[ 1 ], 10 );\r\n\t\taaaa = parseInt( adata[ 2 ], 10 );\r\n\t\txdata = new Date( Date.UTC( aaaa, mm - 1, gg, 12, 0, 0, 0 ) );\r\n\t\tif ( ( xdata.getUTCFullYear() === aaaa ) && ( xdata.getUTCMonth() === mm - 1 ) && ( xdata.getUTCDate() === gg ) ) {\r\n\t\t\tcheck = true;\r\n\t\t} else {\r\n\t\t\tcheck = false;\r\n\t\t}\r\n\t} else {\r\n\t\tcheck = false;\r\n\t}\r\n\treturn this.optional( element ) || check;\r\n}, $.validator.messages.date );\r\n\r\n$.validator.addMethod( \"dateNL\", function( value, element ) {\r\n\treturn this.optional( element ) || /^(0?[1-9]|[12]\\d|3[01])[\\.\\/\\-](0?[1-9]|1[012])[\\.\\/\\-]([12]\\d)?(\\d\\d)$/.test( value );\r\n}, $.validator.messages.date );\r\n\r\n// Older \"accept\" file extension method. Old docs: http://docs.jquery.com/Plugins/Validation/Methods/accept\r\n$.validator.addMethod( \"extension\", function( value, element, param ) {\r\n\tparam = typeof param === \"string\" ? param.replace( /,/g, \"|\" ) : \"png|jpe?g|gif\";\r\n\treturn this.optional( element ) || value.match( new RegExp( \"\\\\.(\" + param + \")$\", \"i\" ) );\r\n}, $.validator.format( \"Please enter a value with a valid extension.\" ) );\r\n\r\n/**\r\n * Dutch giro account numbers (not bank numbers) have max 7 digits\r\n */\r\n$.validator.addMethod( \"giroaccountNL\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[0-9]{1,7}$/.test( value );\r\n}, \"Please specify a valid giro account number\" );\r\n\r\n/**\r\n * IBAN is the international bank account number.\r\n * It has a country - specific format, that is checked here too\r\n *\r\n * Validation is case-insensitive. Please make sure to normalize input yourself.\r\n */\r\n$.validator.addMethod( \"iban\", function( value, element ) {\r\n\r\n\t// Some quick simple tests to prevent needless work\r\n\tif ( this.optional( element ) ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Remove spaces and to upper case\r\n\tvar iban = value.replace( / /g, \"\" ).toUpperCase(),\r\n\t\tibancheckdigits = \"\",\r\n\t\tleadingZeroes = true,\r\n\t\tcRest = \"\",\r\n\t\tcOperator = \"\",\r\n\t\tcountrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;\r\n\r\n\t// Check the country code and find the country specific format\r\n\tcountrycode = iban.substring( 0, 2 );\r\n\tbbancountrypatterns = {\r\n\t\t\"AL\": \"\\\\d{8}[\\\\dA-Z]{16}\",\r\n\t\t\"AD\": \"\\\\d{8}[\\\\dA-Z]{12}\",\r\n\t\t\"AT\": \"\\\\d{16}\",\r\n\t\t\"AZ\": \"[\\\\dA-Z]{4}\\\\d{20}\",\r\n\t\t\"BE\": \"\\\\d{12}\",\r\n\t\t\"BH\": \"[A-Z]{4}[\\\\dA-Z]{14}\",\r\n\t\t\"BA\": \"\\\\d{16}\",\r\n\t\t\"BR\": \"\\\\d{23}[A-Z][\\\\dA-Z]\",\r\n\t\t\"BG\": \"[A-Z]{4}\\\\d{6}[\\\\dA-Z]{8}\",\r\n\t\t\"CR\": \"\\\\d{17}\",\r\n\t\t\"HR\": \"\\\\d{17}\",\r\n\t\t\"CY\": \"\\\\d{8}[\\\\dA-Z]{16}\",\r\n\t\t\"CZ\": \"\\\\d{20}\",\r\n\t\t\"DK\": \"\\\\d{14}\",\r\n\t\t\"DO\": \"[A-Z]{4}\\\\d{20}\",\r\n\t\t\"EE\": \"\\\\d{16}\",\r\n\t\t\"FO\": \"\\\\d{14}\",\r\n\t\t\"FI\": \"\\\\d{14}\",\r\n\t\t\"FR\": \"\\\\d{10}[\\\\dA-Z]{11}\\\\d{2}\",\r\n\t\t\"GE\": \"[\\\\dA-Z]{2}\\\\d{16}\",\r\n\t\t\"DE\": \"\\\\d{18}\",\r\n\t\t\"GI\": \"[A-Z]{4}[\\\\dA-Z]{15}\",\r\n\t\t\"GR\": \"\\\\d{7}[\\\\dA-Z]{16}\",\r\n\t\t\"GL\": \"\\\\d{14}\",\r\n\t\t\"GT\": \"[\\\\dA-Z]{4}[\\\\dA-Z]{20}\",\r\n\t\t\"HU\": \"\\\\d{24}\",\r\n\t\t\"IS\": \"\\\\d{22}\",\r\n\t\t\"IE\": \"[\\\\dA-Z]{4}\\\\d{14}\",\r\n\t\t\"IL\": \"\\\\d{19}\",\r\n\t\t\"IT\": \"[A-Z]\\\\d{10}[\\\\dA-Z]{12}\",\r\n\t\t\"KZ\": \"\\\\d{3}[\\\\dA-Z]{13}\",\r\n\t\t\"KW\": \"[A-Z]{4}[\\\\dA-Z]{22}\",\r\n\t\t\"LV\": \"[A-Z]{4}[\\\\dA-Z]{13}\",\r\n\t\t\"LB\": \"\\\\d{4}[\\\\dA-Z]{20}\",\r\n\t\t\"LI\": \"\\\\d{5}[\\\\dA-Z]{12}\",\r\n\t\t\"LT\": \"\\\\d{16}\",\r\n\t\t\"LU\": \"\\\\d{3}[\\\\dA-Z]{13}\",\r\n\t\t\"MK\": \"\\\\d{3}[\\\\dA-Z]{10}\\\\d{2}\",\r\n\t\t\"MT\": \"[A-Z]{4}\\\\d{5}[\\\\dA-Z]{18}\",\r\n\t\t\"MR\": \"\\\\d{23}\",\r\n\t\t\"MU\": \"[A-Z]{4}\\\\d{19}[A-Z]{3}\",\r\n\t\t\"MC\": \"\\\\d{10}[\\\\dA-Z]{11}\\\\d{2}\",\r\n\t\t\"MD\": \"[\\\\dA-Z]{2}\\\\d{18}\",\r\n\t\t\"ME\": \"\\\\d{18}\",\r\n\t\t\"NL\": \"[A-Z]{4}\\\\d{10}\",\r\n\t\t\"NO\": \"\\\\d{11}\",\r\n\t\t\"PK\": \"[\\\\dA-Z]{4}\\\\d{16}\",\r\n\t\t\"PS\": \"[\\\\dA-Z]{4}\\\\d{21}\",\r\n\t\t\"PL\": \"\\\\d{24}\",\r\n\t\t\"PT\": \"\\\\d{21}\",\r\n\t\t\"RO\": \"[A-Z]{4}[\\\\dA-Z]{16}\",\r\n\t\t\"SM\": \"[A-Z]\\\\d{10}[\\\\dA-Z]{12}\",\r\n\t\t\"SA\": \"\\\\d{2}[\\\\dA-Z]{18}\",\r\n\t\t\"RS\": \"\\\\d{18}\",\r\n\t\t\"SK\": \"\\\\d{20}\",\r\n\t\t\"SI\": \"\\\\d{15}\",\r\n\t\t\"ES\": \"\\\\d{20}\",\r\n\t\t\"SE\": \"\\\\d{20}\",\r\n\t\t\"CH\": \"\\\\d{5}[\\\\dA-Z]{12}\",\r\n\t\t\"TN\": \"\\\\d{20}\",\r\n\t\t\"TR\": \"\\\\d{5}[\\\\dA-Z]{17}\",\r\n\t\t\"AE\": \"\\\\d{3}\\\\d{16}\",\r\n\t\t\"GB\": \"[A-Z]{4}\\\\d{14}\",\r\n\t\t\"VG\": \"[\\\\dA-Z]{4}\\\\d{16}\"\r\n\t};\r\n\r\n\tbbanpattern = bbancountrypatterns[ countrycode ];\r\n\r\n\t// As new countries will start using IBAN in the\r\n\t// future, we only check if the countrycode is known.\r\n\t// This prevents false negatives, while almost all\r\n\t// false positives introduced by this, will be caught\r\n\t// by the checksum validation below anyway.\r\n\t// Strict checking should return FALSE for unknown\r\n\t// countries.\r\n\tif ( typeof bbanpattern !== \"undefined\" ) {\r\n\t\tibanregexp = new RegExp( \"^[A-Z]{2}\\\\d{2}\" + bbanpattern + \"$\", \"\" );\r\n\t\tif ( !( ibanregexp.test( iban ) ) ) {\r\n\t\t\treturn false; // Invalid country specific format\r\n\t\t}\r\n\t}\r\n\r\n\t// Now check the checksum, first convert to digits\r\n\tibancheck = iban.substring( 4, iban.length ) + iban.substring( 0, 4 );\r\n\tfor ( i = 0; i < ibancheck.length; i++ ) {\r\n\t\tcharAt = ibancheck.charAt( i );\r\n\t\tif ( charAt !== \"0\" ) {\r\n\t\t\tleadingZeroes = false;\r\n\t\t}\r\n\t\tif ( !leadingZeroes ) {\r\n\t\t\tibancheckdigits += \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".indexOf( charAt );\r\n\t\t}\r\n\t}\r\n\r\n\t// Calculate the result of: ibancheckdigits % 97\r\n\tfor ( p = 0; p < ibancheckdigits.length; p++ ) {\r\n\t\tcChar = ibancheckdigits.charAt( p );\r\n\t\tcOperator = \"\" + cRest + \"\" + cChar;\r\n\t\tcRest = cOperator % 97;\r\n\t}\r\n\treturn cRest === 1;\r\n}, \"Please specify a valid IBAN\" );\r\n\r\n$.validator.addMethod( \"integer\", function( value, element ) {\r\n\treturn this.optional( element ) || /^-?\\d+$/.test( value );\r\n}, \"A positive or negative non-decimal number please\" );\r\n\r\n$.validator.addMethod( \"ipv4\", function( value, element ) {\r\n\treturn this.optional( element ) || /^(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/i.test( value );\r\n}, \"Please enter a valid IP v4 address.\" );\r\n\r\n$.validator.addMethod( \"ipv6\", function( value, element ) {\r\n\treturn this.optional( element ) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test( value );\r\n}, \"Please enter a valid IP v6 address.\" );\r\n\r\n$.validator.addMethod( \"lettersonly\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[a-z]+$/i.test( value );\r\n}, \"Letters only please\" );\r\n\r\n$.validator.addMethod( \"letterswithbasicpunc\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[a-z\\-.,()'\"\\s]+$/i.test( value );\r\n}, \"Letters or punctuation only please\" );\r\n\r\n$.validator.addMethod( \"mobileNL\", function( value, element ) {\r\n\treturn this.optional( element ) || /^((\\+|00(\\s|\\s?\\-\\s?)?)31(\\s|\\s?\\-\\s?)?(\\(0\\)[\\-\\s]?)?|0)6((\\s|\\s?\\-\\s?)?[0-9]){8}$/.test( value );\r\n}, \"Please specify a valid mobile number\" );\r\n\r\n/* For UK phone functions, do the following server side processing:\r\n * Compare original input with this RegEx pattern:\r\n * ^\\(?(?:(?:00\\)?[\\s\\-]?\\(?|\\+)(44)\\)?[\\s\\-]?\\(?(?:0\\)?[\\s\\-]?\\(?)?|0)([1-9]\\d{1,4}\\)?[\\s\\d\\-]+)$\r\n * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'\r\n * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.\r\n * A number of very detailed GB telephone number RegEx patterns can also be found at:\r\n * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers\r\n */\r\n$.validator.addMethod( \"mobileUK\", function( phone_number, element ) {\r\n\tphone_number = phone_number.replace( /\\(|\\)|\\s+|-/g, \"\" );\r\n\treturn this.optional( element ) || phone_number.length > 9 &&\r\n\t\tphone_number.match( /^(?:(?:(?:00\\s?|\\+)44\\s?|0)7(?:[1345789]\\d{2}|624)\\s?\\d{3}\\s?\\d{3})$/ );\r\n}, \"Please specify a valid mobile number\" );\r\n\r\n/*\r\n * The número de identidad de extranjero ( NIE )is a code used to identify the non-nationals in Spain\r\n */\r\n$.validator.addMethod( \"nieES\", function( value ) {\r\n\t\"use strict\";\r\n\r\n\tvalue = value.toUpperCase();\r\n\r\n\t// Basic format test\r\n\tif ( !value.match( \"((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)\" ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Test NIE\r\n\t//T\r\n\tif ( /^[T]{1}/.test( value ) ) {\r\n\t\treturn ( value[ 8 ] === /^[T]{1}[A-Z0-9]{8}$/.test( value ) );\r\n\t}\r\n\r\n\t//XYZ\r\n\tif ( /^[XYZ]{1}/.test( value ) ) {\r\n\t\treturn (\r\n\t\t\tvalue[ 8 ] === \"TRWAGMYFPDXBNJZSQVHLCKE\".charAt(\r\n\t\t\t\tvalue.replace( \"X\", \"0\" )\r\n\t\t\t\t\t.replace( \"Y\", \"1\" )\r\n\t\t\t\t\t.replace( \"Z\", \"2\" )\r\n\t\t\t\t\t.substring( 0, 8 ) % 23\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}, \"Please specify a valid NIE number.\" );\r\n\r\n/*\r\n * The Número de Identificación Fiscal ( NIF ) is the way tax identification used in Spain for individuals\r\n */\r\n$.validator.addMethod( \"nifES\", function( value ) {\r\n\t\"use strict\";\r\n\r\n\tvalue = value.toUpperCase();\r\n\r\n\t// Basic format test\r\n\tif ( !value.match( \"((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)\" ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Test NIF\r\n\tif ( /^[0-9]{8}[A-Z]{1}$/.test( value ) ) {\r\n\t\treturn ( \"TRWAGMYFPDXBNJZSQVHLCKE\".charAt( value.substring( 8, 0 ) % 23 ) === value.charAt( 8 ) );\r\n\t}\r\n\r\n\t// Test specials NIF (starts with K, L or M)\r\n\tif ( /^[KLM]{1}/.test( value ) ) {\r\n\t\treturn ( value[ 8 ] === String.fromCharCode( 64 ) );\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}, \"Please specify a valid NIF number.\" );\r\n\r\njQuery.validator.addMethod( \"notEqualTo\", function( value, element, param ) {\r\n\treturn this.optional( element ) || !$.validator.methods.equalTo.call( this, value, element, param );\r\n}, \"Please enter a different value, values must not be the same.\" );\r\n\r\n$.validator.addMethod( \"nowhitespace\", function( value, element ) {\r\n\treturn this.optional( element ) || /^\\S+$/i.test( value );\r\n}, \"No white space please\" );\r\n\r\n/**\r\n* Return true if the field value matches the given format RegExp\r\n*\r\n* @example $.validator.methods.pattern(\"AR1004\",element,/^AR\\d{4}$/)\r\n* @result true\r\n*\r\n* @example $.validator.methods.pattern(\"BR1004\",element,/^AR\\d{4}$/)\r\n* @result false\r\n*\r\n* @name $.validator.methods.pattern\r\n* @type Boolean\r\n* @cat Plugins/Validate/Methods\r\n*/\r\n$.validator.addMethod( \"pattern\", function( value, element, param ) {\r\n\tif ( this.optional( element ) ) {\r\n\t\treturn true;\r\n\t}\r\n\tif ( typeof param === \"string\" ) {\r\n\t\tparam = new RegExp( \"^(?:\" + param + \")$\" );\r\n\t}\r\n\treturn param.test( value );\r\n}, \"Invalid format.\" );\r\n\r\n/**\r\n * Dutch phone numbers have 10 digits (or 11 and start with +31).\r\n */\r\n$.validator.addMethod( \"phoneNL\", function( value, element ) {\r\n\treturn this.optional( element ) || /^((\\+|00(\\s|\\s?\\-\\s?)?)31(\\s|\\s?\\-\\s?)?(\\(0\\)[\\-\\s]?)?|0)[1-9]((\\s|\\s?\\-\\s?)?[0-9]){8}$/.test( value );\r\n}, \"Please specify a valid phone number.\" );\r\n\r\n/* For UK phone functions, do the following server side processing:\r\n * Compare original input with this RegEx pattern:\r\n * ^\\(?(?:(?:00\\)?[\\s\\-]?\\(?|\\+)(44)\\)?[\\s\\-]?\\(?(?:0\\)?[\\s\\-]?\\(?)?|0)([1-9]\\d{1,4}\\)?[\\s\\d\\-]+)$\r\n * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'\r\n * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.\r\n * A number of very detailed GB telephone number RegEx patterns can also be found at:\r\n * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers\r\n */\r\n$.validator.addMethod( \"phoneUK\", function( phone_number, element ) {\r\n\tphone_number = phone_number.replace( /\\(|\\)|\\s+|-/g, \"\" );\r\n\treturn this.optional( element ) || phone_number.length > 9 &&\r\n\t\tphone_number.match( /^(?:(?:(?:00\\s?|\\+)44\\s?)|(?:\\(?0))(?:\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}|\\d{3}\\)?\\s?\\d{3}\\s?\\d{3,4}|\\d{4}\\)?\\s?(?:\\d{5}|\\d{3}\\s?\\d{3})|\\d{5}\\)?\\s?\\d{4,5})$/ );\r\n}, \"Please specify a valid phone number\" );\r\n\r\n/**\r\n * Matches US phone number format\r\n *\r\n * where the area code may not start with 1 and the prefix may not start with 1\r\n * allows '-' or ' ' as a separator and allows parens around area code\r\n * some people may want to put a '1' in front of their number\r\n *\r\n * 1(212)-999-2345 or\r\n * 212 999 2344 or\r\n * 212-999-0983\r\n *\r\n * but not\r\n * 111-123-5434\r\n * and not\r\n * 212 123 4567\r\n */\r\n$.validator.addMethod( \"phoneUS\", function( phone_number, element ) {\r\n\tphone_number = phone_number.replace( /\\s+/g, \"\" );\r\n\treturn this.optional( element ) || phone_number.length > 9 &&\r\n\t\tphone_number.match( /^(\\+?1-?)?(\\([2-9]([02-9]\\d|1[02-9])\\)|[2-9]([02-9]\\d|1[02-9]))-?[2-9]([02-9]\\d|1[02-9])-?\\d{4}$/ );\r\n}, \"Please specify a valid phone number\" );\r\n\r\n/* For UK phone functions, do the following server side processing:\r\n * Compare original input with this RegEx pattern:\r\n * ^\\(?(?:(?:00\\)?[\\s\\-]?\\(?|\\+)(44)\\)?[\\s\\-]?\\(?(?:0\\)?[\\s\\-]?\\(?)?|0)([1-9]\\d{1,4}\\)?[\\s\\d\\-]+)$\r\n * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'\r\n * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.\r\n * A number of very detailed GB telephone number RegEx patterns can also be found at:\r\n * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers\r\n */\r\n\r\n// Matches UK landline + mobile, accepting only 01-3 for landline or 07 for mobile to exclude many premium numbers\r\n$.validator.addMethod( \"phonesUK\", function( phone_number, element ) {\r\n\tphone_number = phone_number.replace( /\\(|\\)|\\s+|-/g, \"\" );\r\n\treturn this.optional( element ) || phone_number.length > 9 &&\r\n\t\tphone_number.match( /^(?:(?:(?:00\\s?|\\+)44\\s?|0)(?:1\\d{8,9}|[23]\\d{9}|7(?:[1345789]\\d{8}|624\\d{6})))$/ );\r\n}, \"Please specify a valid uk phone number\" );\r\n\r\n/**\r\n * Matches a valid Canadian Postal Code\r\n *\r\n * @example jQuery.validator.methods.postalCodeCA( \"H0H 0H0\", element )\r\n * @result true\r\n *\r\n * @example jQuery.validator.methods.postalCodeCA( \"H0H0H0\", element )\r\n * @result false\r\n *\r\n * @name jQuery.validator.methods.postalCodeCA\r\n * @type Boolean\r\n * @cat Plugins/Validate/Methods\r\n */\r\n$.validator.addMethod( \"postalCodeCA\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJKLMNPRSTVWXYZ] *\\d[ABCEGHJKLMNPRSTVWXYZ]\\d$/i.test( value );\r\n}, \"Please specify a valid postal code\" );\r\n\r\n/*\r\n* Valida CEPs do brasileiros:\r\n*\r\n* Formatos aceitos:\r\n* 99999-999\r\n* 99.999-999\r\n* 99999999\r\n*/\r\n$.validator.addMethod( \"postalcodeBR\", function( cep_value, element ) {\r\n\treturn this.optional( element ) || /^\\d{2}.\\d{3}-\\d{3}?$|^\\d{5}-?\\d{3}?$/.test( cep_value );\r\n}, \"Informe um CEP válido.\" );\r\n\r\n/* Matches Italian postcode (CAP) */\r\n$.validator.addMethod( \"postalcodeIT\", function( value, element ) {\r\n\treturn this.optional( element ) || /^\\d{5}$/.test( value );\r\n}, \"Please specify a valid postal code\" );\r\n\r\n$.validator.addMethod( \"postalcodeNL\", function( value, element ) {\r\n\treturn this.optional( element ) || /^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$/.test( value );\r\n}, \"Please specify a valid postal code\" );\r\n\r\n// Matches UK postcode. Does not match to UK Channel Islands that have their own postcodes (non standard UK)\r\n$.validator.addMethod( \"postcodeUK\", function( value, element ) {\r\n\treturn this.optional( element ) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\\s?(0AA))$/i.test( value );\r\n}, \"Please specify a valid UK postcode\" );\r\n\r\n/*\r\n * Lets you say \"at least X inputs that match selector Y must be filled.\"\r\n *\r\n * The end result is that neither of these inputs:\r\n *\r\n *\t<input class=\"productinfo\" name=\"partnumber\">\r\n *\t<input class=\"productinfo\" name=\"description\">\r\n *\r\n *\t...will validate unless at least one of them is filled.\r\n *\r\n * partnumber:\t{require_from_group: [1,\".productinfo\"]},\r\n * description: {require_from_group: [1,\".productinfo\"]}\r\n *\r\n * options[0]: number of fields that must be filled in the group\r\n * options[1]: CSS selector that defines the group of conditionally required fields\r\n */\r\n$.validator.addMethod( \"require_from_group\", function( value, element, options ) {\r\n\tvar $fields = $( options[ 1 ], element.form ),\r\n\t\t$fieldsFirst = $fields.eq( 0 ),\r\n\t\tvalidator = $fieldsFirst.data( \"valid_req_grp\" ) ? $fieldsFirst.data( \"valid_req_grp\" ) : $.extend( {}, this ),\r\n\t\tisValid = $fields.filter( function() {\r\n\t\t\treturn validator.elementValue( this );\r\n\t\t} ).length >= options[ 0 ];\r\n\r\n\t// Store the cloned validator for future validation\r\n\t$fieldsFirst.data( \"valid_req_grp\", validator );\r\n\r\n\t// If element isn't being validated, run each require_from_group field's validation rules\r\n\tif ( !$( element ).data( \"being_validated\" ) ) {\r\n\t\t$fields.data( \"being_validated\", true );\r\n\t\t$fields.each( function() {\r\n\t\t\tvalidator.element( this );\r\n\t\t} );\r\n\t\t$fields.data( \"being_validated\", false );\r\n\t}\r\n\treturn isValid;\r\n}, $.validator.format( \"Please fill at least {0} of these fields.\" ) );\r\n\r\n/*\r\n * Lets you say \"either at least X inputs that match selector Y must be filled,\r\n * OR they must all be skipped (left blank).\"\r\n *\r\n * The end result, is that none of these inputs:\r\n *\r\n *\t<input class=\"productinfo\" name=\"partnumber\">\r\n *\t<input class=\"productinfo\" name=\"description\">\r\n *\t<input class=\"productinfo\" name=\"color\">\r\n *\r\n *\t...will validate unless either at least two of them are filled,\r\n *\tOR none of them are.\r\n *\r\n * partnumber:\t{skip_or_fill_minimum: [2,\".productinfo\"]},\r\n * description: {skip_or_fill_minimum: [2,\".productinfo\"]},\r\n * color:\t\t{skip_or_fill_minimum: [2,\".productinfo\"]}\r\n *\r\n * options[0]: number of fields that must be filled in the group\r\n * options[1]: CSS selector that defines the group of conditionally required fields\r\n *\r\n */\r\n$.validator.addMethod( \"skip_or_fill_minimum\", function( value, element, options ) {\r\n\tvar $fields = $( options[ 1 ], element.form ),\r\n\t\t$fieldsFirst = $fields.eq( 0 ),\r\n\t\tvalidator = $fieldsFirst.data( \"valid_skip\" ) ? $fieldsFirst.data( \"valid_skip\" ) : $.extend( {}, this ),\r\n\t\tnumberFilled = $fields.filter( function() {\r\n\t\t\treturn validator.elementValue( this );\r\n\t\t} ).length,\r\n\t\tisValid = numberFilled === 0 || numberFilled >= options[ 0 ];\r\n\r\n\t// Store the cloned validator for future validation\r\n\t$fieldsFirst.data( \"valid_skip\", validator );\r\n\r\n\t// If element isn't being validated, run each skip_or_fill_minimum field's validation rules\r\n\tif ( !$( element ).data( \"being_validated\" ) ) {\r\n\t\t$fields.data( \"being_validated\", true );\r\n\t\t$fields.each( function() {\r\n\t\t\tvalidator.element( this );\r\n\t\t} );\r\n\t\t$fields.data( \"being_validated\", false );\r\n\t}\r\n\treturn isValid;\r\n}, $.validator.format( \"Please either skip these fields or fill at least {0} of them.\" ) );\r\n\r\n/* Validates US States and/or Territories by @jdforsythe\r\n * Can be case insensitive or require capitalization - default is case insensitive\r\n * Can include US Territories or not - default does not\r\n * Can include US Military postal abbreviations (AA, AE, AP) - default does not\r\n *\r\n * Note: \"States\" always includes DC (District of Colombia)\r\n *\r\n * Usage examples:\r\n *\r\n *  This is the default - case insensitive, no territories, no military zones\r\n *  stateInput: {\r\n *     caseSensitive: false,\r\n *     includeTerritories: false,\r\n *     includeMilitary: false\r\n *  }\r\n *\r\n *  Only allow capital letters, no territories, no military zones\r\n *  stateInput: {\r\n *     caseSensitive: false\r\n *  }\r\n *\r\n *  Case insensitive, include territories but not military zones\r\n *  stateInput: {\r\n *     includeTerritories: true\r\n *  }\r\n *\r\n *  Only allow capital letters, include territories and military zones\r\n *  stateInput: {\r\n *     caseSensitive: true,\r\n *     includeTerritories: true,\r\n *     includeMilitary: true\r\n *  }\r\n *\r\n */\r\n$.validator.addMethod( \"stateUS\", function( value, element, options ) {\r\n\tvar isDefault = typeof options === \"undefined\",\r\n\t\tcaseSensitive = ( isDefault || typeof options.caseSensitive === \"undefined\" ) ? false : options.caseSensitive,\r\n\t\tincludeTerritories = ( isDefault || typeof options.includeTerritories === \"undefined\" ) ? false : options.includeTerritories,\r\n\t\tincludeMilitary = ( isDefault || typeof options.includeMilitary === \"undefined\" ) ? false : options.includeMilitary,\r\n\t\tregex;\r\n\r\n\tif ( !includeTerritories && !includeMilitary ) {\r\n\t\tregex = \"^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$\";\r\n\t} else if ( includeTerritories && includeMilitary ) {\r\n\t\tregex = \"^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$\";\r\n\t} else if ( includeTerritories ) {\r\n\t\tregex = \"^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$\";\r\n\t} else {\r\n\t\tregex = \"^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$\";\r\n\t}\r\n\r\n\tregex = caseSensitive ? new RegExp( regex ) : new RegExp( regex, \"i\" );\r\n\treturn this.optional( element ) || regex.test( value );\r\n}, \"Please specify a valid state\" );\r\n\r\n// TODO check if value starts with <, otherwise don't try stripping anything\r\n$.validator.addMethod( \"strippedminlength\", function( value, element, param ) {\r\n\treturn $( value ).text().length >= param;\r\n}, $.validator.format( \"Please enter at least {0} characters\" ) );\r\n\r\n$.validator.addMethod( \"time\", function( value, element ) {\r\n\treturn this.optional( element ) || /^([01]\\d|2[0-3]|[0-9])(:[0-5]\\d){1,2}$/.test( value );\r\n}, \"Please enter a valid time, between 00:00 and 23:59\" );\r\n\r\n$.validator.addMethod( \"time12h\", function( value, element ) {\r\n\treturn this.optional( element ) || /^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ ?[AP]M))$/i.test( value );\r\n}, \"Please enter a valid time in 12-hour am/pm format\" );\r\n\r\n// Same as url, but TLD is optional\r\n$.validator.addMethod( \"url2\", function( value, element ) {\r\n\treturn this.optional( element ) || /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)*(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i.test( value );\r\n}, $.validator.messages.url );\r\n\r\n/**\r\n * Return true, if the value is a valid vehicle identification number (VIN).\r\n *\r\n * Works with all kind of text inputs.\r\n *\r\n * @example <input type=\"text\" size=\"20\" name=\"VehicleID\" class=\"{required:true,vinUS:true}\" />\r\n * @desc Declares a required input element whose value must be a valid vehicle identification number.\r\n *\r\n * @name $.validator.methods.vinUS\r\n * @type Boolean\r\n * @cat Plugins/Validate/Methods\r\n */\r\n$.validator.addMethod( \"vinUS\", function( v ) {\r\n\tif ( v.length !== 17 ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar LL = [ \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\" ],\r\n\t\tVL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ],\r\n\t\tFL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ],\r\n\t\trs = 0,\r\n\t\ti, n, d, f, cd, cdv;\r\n\r\n\tfor ( i = 0; i < 17; i++ ) {\r\n\t\tf = FL[ i ];\r\n\t\td = v.slice( i, i + 1 );\r\n\t\tif ( i === 8 ) {\r\n\t\t\tcdv = d;\r\n\t\t}\r\n\t\tif ( !isNaN( d ) ) {\r\n\t\t\td *= f;\r\n\t\t} else {\r\n\t\t\tfor ( n = 0; n < LL.length; n++ ) {\r\n\t\t\t\tif ( d.toUpperCase() === LL[ n ] ) {\r\n\t\t\t\t\td = VL[ n ];\r\n\t\t\t\t\td *= f;\r\n\t\t\t\t\tif ( isNaN( cdv ) && n === 8 ) {\r\n\t\t\t\t\t\tcdv = LL[ n ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\trs += d;\r\n\t}\r\n\tcd = rs % 11;\r\n\tif ( cd === 10 ) {\r\n\t\tcd = \"X\";\r\n\t}\r\n\tif ( cd === cdv ) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}, \"The specified vehicle identification number (VIN) is invalid.\" );\r\n\r\n$.validator.addMethod( \"zipcodeUS\", function( value, element ) {\r\n\treturn this.optional( element ) || /^\\d{5}(-\\d{4})?$/.test( value );\r\n}, \"The specified US ZIP Code is invalid\" );\r\n\r\n$.validator.addMethod( \"ziprange\", function( value, element ) {\r\n\treturn this.optional( element ) || /^90[2-5]\\d\\{2\\}-\\d{4}$/.test( value );\r\n}, \"Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx\" );\r\n\r\n}));"],"sourceRoot":"/source/"}