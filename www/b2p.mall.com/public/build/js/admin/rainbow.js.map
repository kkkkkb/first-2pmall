{"version":3,"sources":["rainbow.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"rainbow.js","sourcesContent":["/**\r\n * Copyright 2013 Craig Campbell\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * Rainbow is a simple code syntax highlighter\r\n *\r\n * @preserve @version 1.2\r\n * @url rainbowco.de\r\n */\r\nwindow['Rainbow'] = (function() {\r\n\r\n    /**\r\n     * array of replacements to process at the end\r\n     *\r\n     * @type {Object}\r\n     */\r\n    var replacements = {},\r\n\r\n        /**\r\n         * an array of start and end positions of blocks to be replaced\r\n         *\r\n         * @type {Object}\r\n         */\r\n        replacement_positions = {},\r\n\r\n        /**\r\n         * an array of the language patterns specified for each language\r\n         *\r\n         * @type {Object}\r\n         */\r\n        language_patterns = {},\r\n\r\n        /**\r\n         * an array of languages and whether they should bypass the default patterns\r\n         *\r\n         * @type {Object}\r\n         */\r\n        bypass_defaults = {},\r\n\r\n        /**\r\n         * processing level\r\n         *\r\n         * replacements are stored at this level so if there is a sub block of code\r\n         * (for example php inside of html) it runs at a different level\r\n         *\r\n         * @type {number}\r\n         */\r\n        CURRENT_LEVEL = 0,\r\n\r\n        /**\r\n         * constant used to refer to the default language\r\n         *\r\n         * @type {number}\r\n         */\r\n        DEFAULT_LANGUAGE = 0,\r\n\r\n        /**\r\n         * used as counters so we can selectively call setTimeout\r\n         * after processing a certain number of matches/replacements\r\n         *\r\n         * @type {number}\r\n         */\r\n        match_counter = 0,\r\n\r\n        /**\r\n         * @type {number}\r\n         */\r\n        replacement_counter = 0,\r\n\r\n        /**\r\n         * @type {null|string}\r\n         */\r\n        global_class,\r\n\r\n        /**\r\n         * @type {null|Function}\r\n         */\r\n        onHighlight;\r\n\r\n    /**\r\n     * cross browser get attribute for an element\r\n     *\r\n     * @see http://stackoverflow.com/questions/3755227/cross-browser-javascript-getattribute-method\r\n     *\r\n     * @param {Node} el\r\n     * @param {string} attr     attribute you are trying to get\r\n     * @returns {string|number}\r\n     */\r\n    function _attr(el, attr, attrs, i) {\r\n        var result = (el.getAttribute && el.getAttribute(attr)) || 0;\r\n\r\n        if (!result) {\r\n            attrs = el.attributes;\r\n\r\n            for (i = 0; i < attrs.length; ++i) {\r\n                if (attrs[i].nodeName === attr) {\r\n                    return attrs[i].nodeValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * adds a class to a given code block\r\n     *\r\n     * @param {Element} el\r\n     * @param {string} class_name   class name to add\r\n     * @returns void\r\n     */\r\n    function _addClass(el, class_name) {\r\n        el.className += el.className ? ' ' + class_name : class_name;\r\n    }\r\n\r\n    /**\r\n     * checks if a block has a given class\r\n     *\r\n     * @param {Element} el\r\n     * @param {string} class_name   class name to check for\r\n     * @returns {boolean}\r\n     */\r\n    function _hasClass(el, class_name) {\r\n        return (' ' + el.className + ' ').indexOf(' ' + class_name + ' ') > -1;\r\n    }\r\n\r\n    /**\r\n     * gets the language for this block of code\r\n     *\r\n     * @param {Element} block\r\n     * @returns {string|null}\r\n     */\r\n    function _getLanguageForBlock(block) {\r\n\r\n        // if this doesn't have a language but the parent does then use that\r\n        // this means if for example you have: <pre data-language=\"php\">\r\n        // with a bunch of <code> blocks inside then you do not have\r\n        // to specify the language for each block\r\n        var language = _attr(block, 'data-language') || _attr(block.parentNode, 'data-language');\r\n\r\n        // this adds support for specifying language via a css class\r\n        // you can use the Google Code Prettify style: <pre class=\"lang-php\">\r\n        // or the HTML5 style: <pre><code class=\"language-php\">\r\n        if (!language) {\r\n            var pattern = /\\blang(?:uage)?-(\\w+)/,\r\n                match = block.className.match(pattern) || block.parentNode.className.match(pattern);\r\n\r\n            if (match) {\r\n                language = match[1];\r\n            }\r\n        }\r\n\r\n        return language;\r\n    }\r\n\r\n    /**\r\n     * makes sure html entities are always used for tags\r\n     *\r\n     * @param {string} code\r\n     * @returns {string}\r\n     */\r\n    function _htmlEntities(code) {\r\n        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&(?![\\w\\#]+;)/g, '&amp;');\r\n    }\r\n\r\n    /**\r\n     * determines if a new match intersects with an existing one\r\n     *\r\n     * @param {number} start1    start position of existing match\r\n     * @param {number} end1      end position of existing match\r\n     * @param {number} start2    start position of new match\r\n     * @param {number} end2      end position of new match\r\n     * @returns {boolean}\r\n     */\r\n    function _intersects(start1, end1, start2, end2) {\r\n        if (start2 >= start1 && start2 < end1) {\r\n            return true;\r\n        }\r\n\r\n        return end2 > start1 && end2 < end1;\r\n    }\r\n\r\n    /**\r\n     * determines if two different matches have complete overlap with each other\r\n     *\r\n     * @param {number} start1   start position of existing match\r\n     * @param {number} end1     end position of existing match\r\n     * @param {number} start2   start position of new match\r\n     * @param {number} end2     end position of new match\r\n     * @returns {boolean}\r\n     */\r\n    function _hasCompleteOverlap(start1, end1, start2, end2) {\r\n\r\n        // if the starting and end positions are exactly the same\r\n        // then the first one should stay and this one should be ignored\r\n        if (start2 == start1 && end2 == end1) {\r\n            return false;\r\n        }\r\n\r\n        return start2 <= start1 && end2 >= end1;\r\n    }\r\n\r\n    /**\r\n     * determines if the match passed in falls inside of an existing match\r\n     * this prevents a regex pattern from matching inside of a bigger pattern\r\n     *\r\n     * @param {number} start - start position of new match\r\n     * @param {number} end - end position of new match\r\n     * @returns {boolean}\r\n     */\r\n    function _matchIsInsideOtherMatch(start, end) {\r\n        for (var key in replacement_positions[CURRENT_LEVEL]) {\r\n            key = parseInt(key, 10);\r\n\r\n            // if this block completely overlaps with another block\r\n            // then we should remove the other block and return false\r\n            if (_hasCompleteOverlap(key, replacement_positions[CURRENT_LEVEL][key], start, end)) {\r\n                delete replacement_positions[CURRENT_LEVEL][key];\r\n                delete replacements[CURRENT_LEVEL][key];\r\n            }\r\n\r\n            if (_intersects(key, replacement_positions[CURRENT_LEVEL][key], start, end)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * takes a string of code and wraps it in a span tag based on the name\r\n     *\r\n     * @param {string} name     name of the pattern (ie keyword.regex)\r\n     * @param {string} code     block of code to wrap\r\n     * @returns {string}\r\n     */\r\n    function _wrapCodeInSpan(name, code) {\r\n        return '<span class=\"' + name.replace(/\\./g, ' ') + (global_class ? ' ' + global_class : '') + '\">' + code + '</span>';\r\n    }\r\n\r\n    /**\r\n     * finds out the position of group match for a regular expression\r\n     *\r\n     * @see http://stackoverflow.com/questions/1985594/how-to-find-index-of-groups-in-match\r\n     *\r\n     * @param {Object} match\r\n     * @param {number} group_number\r\n     * @returns {number}\r\n     */\r\n    function _indexOfGroup(match, group_number) {\r\n        var index = 0,\r\n            i;\r\n\r\n        for (i = 1; i < group_number; ++i) {\r\n            if (match[i]) {\r\n                index += match[i].length;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * matches a regex pattern against a block of code\r\n     * finds all matches that should be processed and stores the positions\r\n     * of where they should be replaced within the string\r\n     *\r\n     * this is where pretty much all the work is done but it should not\r\n     * be called directly\r\n     *\r\n     * @param {RegExp} pattern\r\n     * @param {string} code\r\n     * @returns void\r\n     */\r\n    function _processPattern(regex, pattern, code, callback)\r\n    {\r\n        if (typeof regex === \"undefined\" || regex === null) {\r\n            //console.warn(\"undefined regular expression\")\r\n            return callback();\r\n        }\r\n        var match = regex.exec(code);\r\n\r\n        if (!match) {\r\n            return callback();\r\n        }\r\n\r\n        ++match_counter;\r\n\r\n        // treat match 0 the same way as name\r\n        if (!pattern['name'] && typeof pattern['matches'][0] == 'string') {\r\n            pattern['name'] = pattern['matches'][0];\r\n            delete pattern['matches'][0];\r\n        }\r\n\r\n        var replacement = match[0],\r\n            start_pos = match.index,\r\n            end_pos = match[0].length + start_pos,\r\n\r\n            /**\r\n             * callback to process the next match of this pattern\r\n             */\r\n            processNext = function() {\r\n                var nextCall = function() {\r\n                    _processPattern(regex, pattern, code, callback);\r\n                };\r\n\r\n                // every 100 items we process let's call set timeout\r\n                // to let the ui breathe a little\r\n                return match_counter % 100 > 0 ? nextCall() : setTimeout(nextCall, 0);\r\n            };\r\n\r\n        // if this is not a child match and it falls inside of another\r\n        // match that already happened we should skip it and continue processing\r\n        if (_matchIsInsideOtherMatch(start_pos, end_pos)) {\r\n            return processNext();\r\n        }\r\n\r\n        /**\r\n         * callback for when a match was successfully processed\r\n         *\r\n         * @param {string} replacement\r\n         * @returns void\r\n         */\r\n        var onMatchSuccess = function(replacement) {\r\n                // if this match has a name then wrap it in a span tag\r\n                if (pattern['name']) {\r\n                    replacement = _wrapCodeInSpan(pattern['name'], replacement);\r\n                }\r\n\r\n                // console.log('LEVEL', CURRENT_LEVEL, 'replace', match[0], 'with', replacement, 'at position', start_pos, 'to', end_pos);\r\n\r\n                // store what needs to be replaced with what at this position\r\n                if (!replacements[CURRENT_LEVEL]) {\r\n                    replacements[CURRENT_LEVEL] = {};\r\n                    replacement_positions[CURRENT_LEVEL] = {};\r\n                }\r\n\r\n                replacements[CURRENT_LEVEL][start_pos] = {\r\n                    'replace': match[0],\r\n                    'with': replacement\r\n                };\r\n\r\n                // store the range of this match so we can use it for comparisons\r\n                // with other matches later\r\n                replacement_positions[CURRENT_LEVEL][start_pos] = end_pos;\r\n\r\n                // process the next match\r\n                processNext();\r\n            },\r\n\r\n            // if this pattern has sub matches for different groups in the regex\r\n            // then we should process them one at a time by rerunning them through\r\n            // this function to generate the new replacement\r\n            //\r\n            // we run through them backwards because the match position of earlier\r\n            // matches will not change depending on what gets replaced in later\r\n            // matches\r\n            group_keys = keys(pattern['matches']),\r\n\r\n            /**\r\n             * callback for processing a sub group\r\n             *\r\n             * @param {number} i\r\n             * @param {Array} group_keys\r\n             * @param {Function} callback\r\n             */\r\n            processGroup = function(i, group_keys, callback) {\r\n                if (i >= group_keys.length) {\r\n                    return callback(replacement);\r\n                }\r\n\r\n                var processNextGroup = function() {\r\n                        processGroup(++i, group_keys, callback);\r\n                    },\r\n                    block = match[group_keys[i]];\r\n\r\n                // if there is no match here then move on\r\n                if (!block) {\r\n                    return processNextGroup();\r\n                }\r\n\r\n                var group = pattern['matches'][group_keys[i]],\r\n                    language = group['language'],\r\n\r\n                    /**\r\n                     * process group is what group we should use to actually process\r\n                     * this match group\r\n                     *\r\n                     * for example if the subgroup pattern looks like this\r\n                     * 2: {\r\n                     *     'name': 'keyword',\r\n                     *     'pattern': /true/g\r\n                     * }\r\n                     *\r\n                     * then we use that as is, but if it looks like this\r\n                     *\r\n                     * 2: {\r\n                     *     'name': 'keyword',\r\n                     *     'matches': {\r\n                     *          'name': 'special',\r\n                     *          'pattern': /whatever/g\r\n                     *      }\r\n                     * }\r\n                     *\r\n                     * we treat the 'matches' part as the pattern and keep\r\n                     * the name around to wrap it with later\r\n                     */\r\n                    process_group = group['name'] && group['matches'] ? group['matches'] : group,\r\n\r\n                    /**\r\n                     * takes the code block matched at this group, replaces it\r\n                     * with the highlighted block, and optionally wraps it with\r\n                     * a span with a name\r\n                     *\r\n                     * @param {string} block\r\n                     * @param {string} replace_block\r\n                     * @param {string|null} match_name\r\n                     */\r\n                    _replaceAndContinue = function(block, replace_block, match_name) {\r\n                        replacement = _replaceAtPosition(_indexOfGroup(match, group_keys[i]), block, match_name ? _wrapCodeInSpan(match_name, replace_block) : replace_block, replacement);\r\n                        processNextGroup();\r\n                    };\r\n\r\n                // if this is a sublanguage go and process the block using that language\r\n                if (language) {\r\n                    return _highlightBlockForLanguage(block, language, function(code) {\r\n                        _replaceAndContinue(block, code);\r\n                    });\r\n                }\r\n\r\n                // if this is a string then this match is directly mapped to selector\r\n                // so all we have to do is wrap it in a span and continue\r\n                if (typeof group === 'string') {\r\n                    return _replaceAndContinue(block, block, group);\r\n                }\r\n\r\n                // the process group can be a single pattern or an array of patterns\r\n                // _processCodeWithPatterns always expects an array so we convert it here\r\n                _processCodeWithPatterns(block, process_group.length ? process_group : [process_group], function(code) {\r\n                    _replaceAndContinue(block, code, group['matches'] ? group['name'] : 0);\r\n                });\r\n            };\r\n\r\n        processGroup(0, group_keys, onMatchSuccess);\r\n    }\r\n\r\n    /**\r\n     * should a language bypass the default patterns?\r\n     *\r\n     * if you call Rainbow.extend() and pass true as the third argument\r\n     * it will bypass the defaults\r\n     */\r\n    function _bypassDefaultPatterns(language)\r\n    {\r\n        return bypass_defaults[language];\r\n    }\r\n\r\n    /**\r\n     * returns a list of regex patterns for this language\r\n     *\r\n     * @param {string} language\r\n     * @returns {Array}\r\n     */\r\n    function _getPatternsForLanguage(language) {\r\n        var patterns = language_patterns[language] || [],\r\n            default_patterns = language_patterns[DEFAULT_LANGUAGE] || [];\r\n\r\n        return _bypassDefaultPatterns(language) ? patterns : patterns.concat(default_patterns);\r\n    }\r\n\r\n    /**\r\n     * substring replace call to replace part of a string at a certain position\r\n     *\r\n     * @param {number} position         the position where the replacement should happen\r\n     * @param {string} replace          the text we want to replace\r\n     * @param {string} replace_with     the text we want to replace it with\r\n     * @param {string} code             the code we are doing the replacing in\r\n     * @returns {string}\r\n     */\r\n    function _replaceAtPosition(position, replace, replace_with, code) {\r\n        var sub_string = code.substr(position);\r\n        return code.substr(0, position) + sub_string.replace(replace, replace_with);\r\n    }\r\n\r\n   /**\r\n     * sorts an object by index descending\r\n     *\r\n     * @param {Object} object\r\n     * @return {Array}\r\n     */\r\n    function keys(object) {\r\n        var locations = [],\r\n            replacement,\r\n            pos;\r\n\r\n        for(var location in object) {\r\n            if (object.hasOwnProperty(location)) {\r\n                locations.push(location);\r\n            }\r\n        }\r\n\r\n        // numeric descending\r\n        return locations.sort(function(a, b) {\r\n            return b - a;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * processes a block of code using specified patterns\r\n     *\r\n     * @param {string} code\r\n     * @param {Array} patterns\r\n     * @returns void\r\n     */\r\n    function _processCodeWithPatterns(code, patterns, callback)\r\n    {\r\n        // we have to increase the level here so that the\r\n        // replacements will not conflict with each other when\r\n        // processing sub blocks of code\r\n        ++CURRENT_LEVEL;\r\n\r\n        // patterns are processed one at a time through this function\r\n        function _workOnPatterns(patterns, i)\r\n        {\r\n            // still have patterns to process, keep going\r\n            if (i < patterns.length) {\r\n                return _processPattern(patterns[i]['pattern'], patterns[i], code, function() {\r\n                    _workOnPatterns(patterns, ++i);\r\n                });\r\n            }\r\n\r\n            // we are done processing the patterns\r\n            // process the replacements and update the DOM\r\n            _processReplacements(code, function(code) {\r\n\r\n                // when we are done processing replacements\r\n                // we are done at this level so we can go back down\r\n                delete replacements[CURRENT_LEVEL];\r\n                delete replacement_positions[CURRENT_LEVEL];\r\n                --CURRENT_LEVEL;\r\n                callback(code);\r\n            });\r\n        }\r\n\r\n        _workOnPatterns(patterns, 0);\r\n    }\r\n\r\n    /**\r\n     * process replacements in the string of code to actually update the markup\r\n     *\r\n     * @param {string} code         the code to process replacements in\r\n     * @param {Function} onComplete   what to do when we are done processing\r\n     * @returns void\r\n     */\r\n    function _processReplacements(code, onComplete) {\r\n\r\n        /**\r\n         * processes a single replacement\r\n         *\r\n         * @param {string} code\r\n         * @param {Array} positions\r\n         * @param {number} i\r\n         * @param {Function} onComplete\r\n         * @returns void\r\n         */\r\n        function _processReplacement(code, positions, i, onComplete) {\r\n            if (i < positions.length) {\r\n                ++replacement_counter;\r\n                var pos = positions[i],\r\n                    replacement = replacements[CURRENT_LEVEL][pos];\r\n                code = _replaceAtPosition(pos, replacement['replace'], replacement['with'], code);\r\n\r\n                // process next function\r\n                var next = function() {\r\n                    _processReplacement(code, positions, ++i, onComplete);\r\n                };\r\n\r\n                // use a timeout every 250 to not freeze up the UI\r\n                return replacement_counter % 250 > 0 ? next() : setTimeout(next, 0);\r\n            }\r\n\r\n            onComplete(code);\r\n        }\r\n\r\n        var string_positions = keys(replacements[CURRENT_LEVEL]);\r\n        try {\r\n\t\t\t_processReplacement(code, string_positions, 0, onComplete);\r\n\t\t}catch(e){}\r\n    }\r\n\r\n    /**\r\n     * takes a string of code and highlights it according to the language specified\r\n     *\r\n     * @param {string} code\r\n     * @param {string} language\r\n     * @param {Function} onComplete\r\n     * @returns void\r\n     */\r\n    function _highlightBlockForLanguage(code, language, onComplete) {\r\n        var patterns = _getPatternsForLanguage(language);\r\n        _processCodeWithPatterns(_htmlEntities(code), patterns, onComplete);\r\n    }\r\n\r\n    /**\r\n     * highlight an individual code block\r\n     *\r\n     * @param {Array} code_blocks\r\n     * @param {number} i\r\n     * @returns void\r\n     */\r\n    function _highlightCodeBlock(code_blocks, i, onComplete) {\r\n        if (i < code_blocks.length) {\r\n            var block = code_blocks[i],\r\n                language = _getLanguageForBlock(block);\r\n\r\n            if (!_hasClass(block, 'rainbow') && language) {\r\n                language = language.toLowerCase();\r\n\r\n                _addClass(block, 'rainbow');\r\n\r\n                return _highlightBlockForLanguage(block.innerHTML, language, function(code) {\r\n                    block.innerHTML = code;\r\n\r\n                    // reset the replacement arrays\r\n                    replacements = {};\r\n                    replacement_positions = {};\r\n\r\n                    // if you have a listener attached tell it that this block is now highlighted\r\n                    if (onHighlight) {\r\n                        onHighlight(block, language);\r\n                    }\r\n\r\n                    // process the next block\r\n                    setTimeout(function() {\r\n                        _highlightCodeBlock(code_blocks, ++i, onComplete);\r\n                    }, 0);\r\n                });\r\n            }\r\n            return _highlightCodeBlock(code_blocks, ++i, onComplete);\r\n        }\r\n\r\n        if (onComplete) {\r\n            onComplete();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * start highlighting all the code blocks\r\n     *\r\n     * @returns void\r\n     */\r\n    function _highlight(node, onComplete) {\r\n\r\n        // the first argument can be an Event or a DOM Element\r\n        // I was originally checking instanceof Event but that makes it break\r\n        // when using mootools\r\n        //\r\n        // @see https://github.com/ccampbell/rainbow/issues/32\r\n        //\r\n        node = node && typeof node.getElementsByTagName == 'function' ? node : document;\r\n\r\n        var pre_blocks = node.getElementsByTagName('pre'),\r\n            code_blocks = node.getElementsByTagName('code'),\r\n            i,\r\n            final_pre_blocks = [],\r\n            final_code_blocks = [];\r\n\r\n        // first loop through all pre blocks to find which ones to highlight\r\n        // also strip whitespace\r\n        for (i = 0; i < pre_blocks.length; ++i) {\r\n\r\n            // strip whitespace around code tags when they are inside of a pre tag\r\n            // this makes the themes look better because you can't accidentally\r\n            // add extra linebreaks at the start and end\r\n            //\r\n            // when the pre tag contains a code tag then strip any extra whitespace\r\n            // for example\r\n            // <pre>\r\n            //      <code>var foo = true;</code>\r\n            // </pre>\r\n            //\r\n            // will become\r\n            // <pre><code>var foo = true;</code></pre>\r\n            //\r\n            // if you want to preserve whitespace you can use a pre tag on its own\r\n            // without a code tag inside of it\r\n            if (pre_blocks[i].getElementsByTagName('code').length) {\r\n                pre_blocks[i].innerHTML = pre_blocks[i].innerHTML.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n                continue;\r\n            }\r\n\r\n            // if the pre block has no code blocks then we are going to want to\r\n            // process it directly\r\n            final_pre_blocks.push(pre_blocks[i]);\r\n        }\r\n\r\n        // @see http://stackoverflow.com/questions/2735067/how-to-convert-a-dom-node-list-to-an-array-in-javascript\r\n        // we are going to process all <code> blocks\r\n        for (i = 0; i < code_blocks.length; ++i) {\r\n            final_code_blocks.push(code_blocks[i]);\r\n        }\r\n\r\n        _highlightCodeBlock(final_code_blocks.concat(final_pre_blocks), 0, onComplete);\r\n    }\r\n\r\n    /**\r\n     * public methods\r\n     */\r\n    return {\r\n\r\n        /**\r\n         * extends the language pattern matches\r\n         *\r\n         * @param {*} language     name of language\r\n         * @param {*} patterns      array of patterns to add on\r\n         * @param {boolean|null} bypass      if true this will bypass the default language patterns\r\n         */\r\n        extend: function(language, patterns, bypass) {\r\n\r\n            // if there is only one argument then we assume that we want to\r\n            // extend the default language rules\r\n            if (arguments.length == 1) {\r\n                patterns = language;\r\n                language = DEFAULT_LANGUAGE;\r\n            }\r\n\r\n            bypass_defaults[language] = bypass;\r\n            language_patterns[language] = patterns.concat(language_patterns[language] || []);\r\n        },\r\n\r\n        /**\r\n         * call back to let you do stuff in your app after a piece of code has been highlighted\r\n         *\r\n         * @param {Function} callback\r\n         */\r\n        onHighlight: function(callback) {\r\n            onHighlight = callback;\r\n        },\r\n\r\n        /**\r\n         * method to set a global class that will be applied to all spans\r\n         *\r\n         * @param {string} class_name\r\n         */\r\n        addClass: function(class_name) {\r\n            global_class = class_name;\r\n        },\r\n\r\n        /**\r\n         * starts the magic rainbow\r\n         *\r\n         * @returns void\r\n         */\r\n        color: function() {\r\n\r\n            // if you want to straight up highlight a string you can pass the string of code,\r\n            // the language, and a callback function\r\n            if (typeof arguments[0] == 'string') {\r\n                return _highlightBlockForLanguage(arguments[0], arguments[1], arguments[2]);\r\n            }\r\n\r\n            // if you pass a callback function then we rerun the color function\r\n            // on all the code and call the callback function on complete\r\n            if (typeof arguments[0] == 'function') {\r\n                return _highlight(0, arguments[0]);\r\n            }\r\n\r\n            // otherwise we use whatever node you passed in with an optional\r\n            // callback function as the second parameter\r\n            _highlight(arguments[0], arguments[1]);\r\n        }\r\n    };\r\n}) ();\r\n\r\n/**\r\n * adds event listener to start highlighting\r\n */\r\n(function() {\r\n    if (document.addEventListener) {\r\n        return document.addEventListener('DOMContentLoaded', Rainbow.color, false);\r\n    }\r\n    window.attachEvent('onload', Rainbow.color);\r\n}) ();\r\n\r\n// When using Google closure compiler in advanced mode some methods\r\n// get renamed.  This keeps a public reference to these methods so they can\r\n// still be referenced from outside this library.\r\nRainbow[\"onHighlight\"] = Rainbow.onHighlight;\r\nRainbow[\"addClass\"] = Rainbow.addClass;\r\n"],"sourceRoot":"/source/"}