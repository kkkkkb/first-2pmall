{"version":3,"sources":["jquery.mobile.custom.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.mobile.custom.js","sourcesContent":["/*\r\n* jQuery Mobile v1.4.5\r\n* http://jquerymobile.com\r\n*\r\n* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors\r\n* Released under the MIT license.\r\n* http://jquery.org/license\r\n*\r\n*/\r\n\r\n(function ( root, doc, factory ) {\r\n\tif ( typeof define === \"function\" && define.amd ) {\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine( [ \"jquery\" ], function ( $ ) {\r\n\t\t\tfactory( $, root, doc );\r\n\t\t\treturn $.mobile;\r\n\t\t});\r\n\t} else {\r\n\t\t// Browser globals\r\n\t\tfactory( root.jQuery, root, doc );\r\n\t}\r\n}( this, document, function ( jQuery, window, document, undefined ) {// This plugin is an experiment for abstracting away the touch and mouse\r\n// events so that developers don't have to worry about which method of input\r\n// the device their document is loaded on supports.\r\n//\r\n// The idea here is to allow the developer to register listeners for the\r\n// basic mouse events, such as mousedown, mousemove, mouseup, and click,\r\n// and the plugin will take care of registering the correct listeners\r\n// behind the scenes to invoke the listener at the fastest possible time\r\n// for that device, while still retaining the order of event firing in\r\n// the traditional mouse environment, should multiple handlers be registered\r\n// on the same element for different events.\r\n//\r\n// The current version exposes the following virtual events to jQuery bind methods:\r\n// \"vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel\"\r\n\r\n(function( $, window, document, undefined ) {\r\n\r\nvar dataPropertyName = \"virtualMouseBindings\",\r\n\ttouchTargetPropertyName = \"virtualTouchID\",\r\n\tvirtualEventNames = \"vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel\".split( \" \" ),\r\n\ttouchEventProps = \"clientX clientY pageX pageY screenX screenY\".split( \" \" ),\r\n\tmouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],\r\n\tmouseEventProps = $.event.props.concat( mouseHookProps ),\r\n\tactiveDocHandlers = {},\r\n\tresetTimerID = 0,\r\n\tstartX = 0,\r\n\tstartY = 0,\r\n\tdidScroll = false,\r\n\tclickBlockList = [],\r\n\tblockMouseTriggers = false,\r\n\tblockTouchTriggers = false,\r\n\teventCaptureSupported = \"addEventListener\" in document,\r\n\t$document = $( document ),\r\n\tnextTouchID = 1,\r\n\tlastTouchID = 0, threshold,\r\n\ti;\r\n\r\n$.vmouse = {\r\n\tmoveDistanceThreshold: 10,\r\n\tclickDistanceThreshold: 10,\r\n\tresetTimerDuration: 1500\r\n};\r\n\r\nfunction getNativeEvent( event ) {\r\n\r\n\twhile ( event && typeof event.originalEvent !== \"undefined\" ) {\r\n\t\tevent = event.originalEvent;\r\n\t}\r\n\treturn event;\r\n}\r\n\r\nfunction createVirtualEvent( event, eventType ) {\r\n\r\n\tvar t = event.type,\r\n\t\toe, props, ne, prop, ct, touch, i, j, len;\r\n\r\n\tevent = $.Event( event );\r\n\tevent.type = eventType;\r\n\r\n\toe = event.originalEvent;\r\n\tprops = $.event.props;\r\n\r\n\t// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280\r\n\t// https://github.com/jquery/jquery-mobile/issues/3280\r\n\tif ( t.search( /^(mouse|click)/ ) > -1 ) {\r\n\t\tprops = mouseEventProps;\r\n\t}\r\n\r\n\t// copy original event properties over to the new event\r\n\t// this would happen if we could call $.event.fix instead of $.Event\r\n\t// but we don't have a way to force an event to be fixed multiple times\r\n\tif ( oe ) {\r\n\t\tfor ( i = props.length, prop; i; ) {\r\n\t\t\tprop = props[ --i ];\r\n\t\t\tevent[ prop ] = oe[ prop ];\r\n\t\t}\r\n\t}\r\n\r\n\t// make sure that if the mouse and click virtual events are generated\r\n\t// without a .which one is defined\r\n\tif ( t.search(/mouse(down|up)|click/) > -1 && !event.which ) {\r\n\t\tevent.which = 1;\r\n\t}\r\n\r\n\tif ( t.search(/^touch/) !== -1 ) {\r\n\t\tne = getNativeEvent( oe );\r\n\t\tt = ne.touches;\r\n\t\tct = ne.changedTouches;\r\n\t\ttouch = ( t && t.length ) ? t[0] : ( ( ct && ct.length ) ? ct[ 0 ] : undefined );\r\n\r\n\t\tif ( touch ) {\r\n\t\t\tfor ( j = 0, len = touchEventProps.length; j < len; j++) {\r\n\t\t\t\tprop = touchEventProps[ j ];\r\n\t\t\t\tevent[ prop ] = touch[ prop ];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn event;\r\n}\r\n\r\nfunction getVirtualBindingFlags( element ) {\r\n\r\n\tvar flags = {},\r\n\t\tb, k;\r\n\r\n\twhile ( element ) {\r\n\r\n\t\tb = $.data( element, dataPropertyName );\r\n\r\n\t\tfor (  k in b ) {\r\n\t\t\tif ( b[ k ] ) {\r\n\t\t\t\tflags[ k ] = flags.hasVirtualBinding = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telement = element.parentNode;\r\n\t}\r\n\treturn flags;\r\n}\r\n\r\nfunction getClosestElementWithVirtualBinding( element, eventType ) {\r\n\tvar b;\r\n\twhile ( element ) {\r\n\r\n\t\tb = $.data( element, dataPropertyName );\r\n\r\n\t\tif ( b && ( !eventType || b[ eventType ] ) ) {\r\n\t\t\treturn element;\r\n\t\t}\r\n\t\telement = element.parentNode;\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nfunction enableTouchBindings() {\r\n\tblockTouchTriggers = false;\r\n}\r\n\r\nfunction disableTouchBindings() {\r\n\tblockTouchTriggers = true;\r\n}\r\n\r\nfunction enableMouseBindings() {\r\n\tlastTouchID = 0;\r\n\tclickBlockList.length = 0;\r\n\tblockMouseTriggers = false;\r\n\r\n\t// When mouse bindings are enabled, our\r\n\t// touch bindings are disabled.\r\n\tdisableTouchBindings();\r\n}\r\n\r\nfunction disableMouseBindings() {\r\n\t// When mouse bindings are disabled, our\r\n\t// touch bindings are enabled.\r\n\tenableTouchBindings();\r\n}\r\n\r\nfunction startResetTimer() {\r\n\tclearResetTimer();\r\n\tresetTimerID = setTimeout( function() {\r\n\t\tresetTimerID = 0;\r\n\t\tenableMouseBindings();\r\n\t}, $.vmouse.resetTimerDuration );\r\n}\r\n\r\nfunction clearResetTimer() {\r\n\tif ( resetTimerID ) {\r\n\t\tclearTimeout( resetTimerID );\r\n\t\tresetTimerID = 0;\r\n\t}\r\n}\r\n\r\nfunction triggerVirtualEvent( eventType, event, flags ) {\r\n\tvar ve;\r\n\r\n\tif ( ( flags && flags[ eventType ] ) ||\r\n\t\t\t\t( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {\r\n\r\n\t\tve = createVirtualEvent( event, eventType );\r\n\r\n\t\t$( event.target).trigger( ve );\r\n\t}\r\n\r\n\treturn ve;\r\n}\r\n\r\nfunction mouseEventCallback( event ) {\r\n\tvar touchID = $.data( event.target, touchTargetPropertyName ),\r\n\t\tve;\r\n\r\n\tif ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ) {\r\n\t\tve = triggerVirtualEvent( \"v\" + event.type, event );\r\n\t\tif ( ve ) {\r\n\t\t\tif ( ve.isDefaultPrevented() ) {\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\t\t\tif ( ve.isPropagationStopped() ) {\r\n\t\t\t\tevent.stopPropagation();\r\n\t\t\t}\r\n\t\t\tif ( ve.isImmediatePropagationStopped() ) {\r\n\t\t\t\tevent.stopImmediatePropagation();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction handleTouchStart( event ) {\r\n\r\n\tvar touches = getNativeEvent( event ).touches,\r\n\t\ttarget, flags, t;\r\n\r\n\tif ( touches && touches.length === 1 ) {\r\n\r\n\t\ttarget = event.target;\r\n\t\tflags = getVirtualBindingFlags( target );\r\n\r\n\t\tif ( flags.hasVirtualBinding ) {\r\n\r\n\t\t\tlastTouchID = nextTouchID++;\r\n\t\t\t$.data( target, touchTargetPropertyName, lastTouchID );\r\n\r\n\t\t\tclearResetTimer();\r\n\r\n\t\t\tdisableMouseBindings();\r\n\t\t\tdidScroll = false;\r\n\r\n\t\t\tt = getNativeEvent( event ).touches[ 0 ];\r\n\t\t\tstartX = t.pageX;\r\n\t\t\tstartY = t.pageY;\r\n\r\n\t\t\ttriggerVirtualEvent( \"vmouseover\", event, flags );\r\n\t\t\ttriggerVirtualEvent( \"vmousedown\", event, flags );\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction handleScroll( event ) {\r\n\tif ( blockTouchTriggers ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ( !didScroll ) {\r\n\t\ttriggerVirtualEvent( \"vmousecancel\", event, getVirtualBindingFlags( event.target ) );\r\n\t}\r\n\r\n\tdidScroll = true;\r\n\tstartResetTimer();\r\n}\r\n\r\nfunction handleTouchMove( event ) {\r\n\tif ( blockTouchTriggers ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar t = getNativeEvent( event ).touches[ 0 ],\r\n\t\tdidCancel = didScroll,\r\n\t\tmoveThreshold = $.vmouse.moveDistanceThreshold,\r\n\t\tflags = getVirtualBindingFlags( event.target );\r\n\r\n\t\tdidScroll = didScroll ||\r\n\t\t\t( Math.abs( t.pageX - startX ) > moveThreshold ||\r\n\t\t\t\tMath.abs( t.pageY - startY ) > moveThreshold );\r\n\r\n\tif ( didScroll && !didCancel ) {\r\n\t\ttriggerVirtualEvent( \"vmousecancel\", event, flags );\r\n\t}\r\n\r\n\ttriggerVirtualEvent( \"vmousemove\", event, flags );\r\n\tstartResetTimer();\r\n}\r\n\r\nfunction handleTouchEnd( event ) {\r\n\tif ( blockTouchTriggers ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tdisableTouchBindings();\r\n\r\n\tvar flags = getVirtualBindingFlags( event.target ),\r\n\t\tve, t;\r\n\ttriggerVirtualEvent( \"vmouseup\", event, flags );\r\n\r\n\tif ( !didScroll ) {\r\n\t\tve = triggerVirtualEvent( \"vclick\", event, flags );\r\n\t\tif ( ve && ve.isDefaultPrevented() ) {\r\n\t\t\t// The target of the mouse events that follow the touchend\r\n\t\t\t// event don't necessarily match the target used during the\r\n\t\t\t// touch. This means we need to rely on coordinates for blocking\r\n\t\t\t// any click that is generated.\r\n\t\t\tt = getNativeEvent( event ).changedTouches[ 0 ];\r\n\t\t\tclickBlockList.push({\r\n\t\t\t\ttouchID: lastTouchID,\r\n\t\t\t\tx: t.clientX,\r\n\t\t\t\ty: t.clientY\r\n\t\t\t});\r\n\r\n\t\t\t// Prevent any mouse events that follow from triggering\r\n\t\t\t// virtual event notifications.\r\n\t\t\tblockMouseTriggers = true;\r\n\t\t}\r\n\t}\r\n\ttriggerVirtualEvent( \"vmouseout\", event, flags);\r\n\tdidScroll = false;\r\n\r\n\tstartResetTimer();\r\n}\r\n\r\nfunction hasVirtualBindings( ele ) {\r\n\tvar bindings = $.data( ele, dataPropertyName ),\r\n\t\tk;\r\n\r\n\tif ( bindings ) {\r\n\t\tfor ( k in bindings ) {\r\n\t\t\tif ( bindings[ k ] ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nfunction dummyMouseHandler() {}\r\n\r\nfunction getSpecialEventObject( eventType ) {\r\n\tvar realType = eventType.substr( 1 );\r\n\r\n\treturn {\r\n\t\tsetup: function(/* data, namespace */) {\r\n\t\t\t// If this is the first virtual mouse binding for this element,\r\n\t\t\t// add a bindings object to its data.\r\n\r\n\t\t\tif ( !hasVirtualBindings( this ) ) {\r\n\t\t\t\t$.data( this, dataPropertyName, {} );\r\n\t\t\t}\r\n\r\n\t\t\t// If setup is called, we know it is the first binding for this\r\n\t\t\t// eventType, so initialize the count for the eventType to zero.\r\n\t\t\tvar bindings = $.data( this, dataPropertyName );\r\n\t\t\tbindings[ eventType ] = true;\r\n\r\n\t\t\t// If this is the first virtual mouse event for this type,\r\n\t\t\t// register a global handler on the document.\r\n\r\n\t\t\tactiveDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;\r\n\r\n\t\t\tif ( activeDocHandlers[ eventType ] === 1 ) {\r\n\t\t\t\t$document.bind( realType, mouseEventCallback );\r\n\t\t\t}\r\n\r\n\t\t\t// Some browsers, like Opera Mini, won't dispatch mouse/click events\r\n\t\t\t// for elements unless they actually have handlers registered on them.\r\n\t\t\t// To get around this, we register dummy handlers on the elements.\r\n\r\n\t\t\t$( this ).bind( realType, dummyMouseHandler );\r\n\r\n\t\t\t// For now, if event capture is not supported, we rely on mouse handlers.\r\n\t\t\tif ( eventCaptureSupported ) {\r\n\t\t\t\t// If this is the first virtual mouse binding for the document,\r\n\t\t\t\t// register our touchstart handler on the document.\r\n\r\n\t\t\t\tactiveDocHandlers[ \"touchstart\" ] = ( activeDocHandlers[ \"touchstart\" ] || 0) + 1;\r\n\r\n\t\t\t\tif ( activeDocHandlers[ \"touchstart\" ] === 1 ) {\r\n\t\t\t\t\t$document.bind( \"touchstart\", handleTouchStart )\r\n\t\t\t\t\t\t.bind( \"touchend\", handleTouchEnd )\r\n\r\n\t\t\t\t\t\t// On touch platforms, touching the screen and then dragging your finger\r\n\t\t\t\t\t\t// causes the window content to scroll after some distance threshold is\r\n\t\t\t\t\t\t// exceeded. On these platforms, a scroll prevents a click event from being\r\n\t\t\t\t\t\t// dispatched, and on some platforms, even the touchend is suppressed. To\r\n\t\t\t\t\t\t// mimic the suppression of the click event, we need to watch for a scroll\r\n\t\t\t\t\t\t// event. Unfortunately, some platforms like iOS don't dispatch scroll\r\n\t\t\t\t\t\t// events until *AFTER* the user lifts their finger (touchend). This means\r\n\t\t\t\t\t\t// we need to watch both scroll and touchmove events to figure out whether\r\n\t\t\t\t\t\t// or not a scroll happenens before the touchend event is fired.\r\n\r\n\t\t\t\t\t\t.bind( \"touchmove\", handleTouchMove )\r\n\t\t\t\t\t\t.bind( \"scroll\", handleScroll );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tteardown: function(/* data, namespace */) {\r\n\t\t\t// If this is the last virtual binding for this eventType,\r\n\t\t\t// remove its global handler from the document.\r\n\r\n\t\t\t--activeDocHandlers[ eventType ];\r\n\r\n\t\t\tif ( !activeDocHandlers[ eventType ] ) {\r\n\t\t\t\t$document.unbind( realType, mouseEventCallback );\r\n\t\t\t}\r\n\r\n\t\t\tif ( eventCaptureSupported ) {\r\n\t\t\t\t// If this is the last virtual mouse binding in existence,\r\n\t\t\t\t// remove our document touchstart listener.\r\n\r\n\t\t\t\t--activeDocHandlers[ \"touchstart\" ];\r\n\r\n\t\t\t\tif ( !activeDocHandlers[ \"touchstart\" ] ) {\r\n\t\t\t\t\t$document.unbind( \"touchstart\", handleTouchStart )\r\n\t\t\t\t\t\t.unbind( \"touchmove\", handleTouchMove )\r\n\t\t\t\t\t\t.unbind( \"touchend\", handleTouchEnd )\r\n\t\t\t\t\t\t.unbind( \"scroll\", handleScroll );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar $this = $( this ),\r\n\t\t\t\tbindings = $.data( this, dataPropertyName );\r\n\r\n\t\t\t// teardown may be called when an element was\r\n\t\t\t// removed from the DOM. If this is the case,\r\n\t\t\t// jQuery core may have already stripped the element\r\n\t\t\t// of any data bindings so we need to check it before\r\n\t\t\t// using it.\r\n\t\t\tif ( bindings ) {\r\n\t\t\t\tbindings[ eventType ] = false;\r\n\t\t\t}\r\n\r\n\t\t\t// Unregister the dummy event handler.\r\n\r\n\t\t\t$this.unbind( realType, dummyMouseHandler );\r\n\r\n\t\t\t// If this is the last virtual mouse binding on the\r\n\t\t\t// element, remove the binding data from the element.\r\n\r\n\t\t\tif ( !hasVirtualBindings( this ) ) {\r\n\t\t\t\t$this.removeData( dataPropertyName );\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// Expose our custom events to the jQuery bind/unbind mechanism.\r\n\r\nfor ( i = 0; i < virtualEventNames.length; i++ ) {\r\n\t$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );\r\n}\r\n\r\n// Add a capture click handler to block clicks.\r\n// Note that we require event capture support for this so if the device\r\n// doesn't support it, we punt for now and rely solely on mouse events.\r\nif ( eventCaptureSupported ) {\r\n\tdocument.addEventListener( \"click\", function( e ) {\r\n\t\tvar cnt = clickBlockList.length,\r\n\t\t\ttarget = e.target,\r\n\t\t\tx, y, ele, i, o, touchID;\r\n\r\n\t\tif ( cnt ) {\r\n\t\t\tx = e.clientX;\r\n\t\t\ty = e.clientY;\r\n\t\t\tthreshold = $.vmouse.clickDistanceThreshold;\r\n\r\n\t\t\t// The idea here is to run through the clickBlockList to see if\r\n\t\t\t// the current click event is in the proximity of one of our\r\n\t\t\t// vclick events that had preventDefault() called on it. If we find\r\n\t\t\t// one, then we block the click.\r\n\t\t\t//\r\n\t\t\t// Why do we have to rely on proximity?\r\n\t\t\t//\r\n\t\t\t// Because the target of the touch event that triggered the vclick\r\n\t\t\t// can be different from the target of the click event synthesized\r\n\t\t\t// by the browser. The target of a mouse/click event that is synthesized\r\n\t\t\t// from a touch event seems to be implementation specific. For example,\r\n\t\t\t// some browsers will fire mouse/click events for a link that is near\r\n\t\t\t// a touch event, even though the target of the touchstart/touchend event\r\n\t\t\t// says the user touched outside the link. Also, it seems that with most\r\n\t\t\t// browsers, the target of the mouse/click event is not calculated until the\r\n\t\t\t// time it is dispatched, so if you replace an element that you touched\r\n\t\t\t// with another element, the target of the mouse/click will be the new\r\n\t\t\t// element underneath that point.\r\n\t\t\t//\r\n\t\t\t// Aside from proximity, we also check to see if the target and any\r\n\t\t\t// of its ancestors were the ones that blocked a click. This is necessary\r\n\t\t\t// because of the strange mouse/click target calculation done in the\r\n\t\t\t// Android 2.1 browser, where if you click on an element, and there is a\r\n\t\t\t// mouse/click handler on one of its ancestors, the target will be the\r\n\t\t\t// innermost child of the touched element, even if that child is no where\r\n\t\t\t// near the point of touch.\r\n\r\n\t\t\tele = target;\r\n\r\n\t\t\twhile ( ele ) {\r\n\t\t\t\tfor ( i = 0; i < cnt; i++ ) {\r\n\t\t\t\t\to = clickBlockList[ i ];\r\n\t\t\t\t\ttouchID = 0;\r\n\r\n\t\t\t\t\tif ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||\r\n\t\t\t\t\t\t\t\t$.data( ele, touchTargetPropertyName ) === o.touchID ) {\r\n\t\t\t\t\t\t// XXX: We may want to consider removing matches from the block list\r\n\t\t\t\t\t\t//      instead of waiting for the reset timer to fire.\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tele = ele.parentNode;\r\n\t\t\t}\r\n\t\t}\r\n\t}, true);\r\n}\r\n})( jQuery, window, document );\r\n\r\n(function( $ ) {\r\n\t$.mobile = {};\r\n}( jQuery ));\r\n\r\n\t(function( $, undefined ) {\r\n\t\tvar support = {\r\n\t\t\ttouch: \"ontouchend\" in document\r\n\t\t};\r\n\r\n\t\t$.mobile.support = $.mobile.support || {};\r\n\t\t$.extend( $.support, support );\r\n\t\t$.extend( $.mobile.support, support );\r\n\t}( jQuery ));\r\n\r\n\r\n(function( $, window, undefined ) {\r\n\tvar $document = $( document ),\r\n\t\tsupportTouch = $.mobile.support.touch,\r\n\t\tscrollEvent = \"touchmove scroll\",\r\n\t\ttouchStartEvent = supportTouch ? \"touchstart\" : \"mousedown\",\r\n\t\ttouchStopEvent = supportTouch ? \"touchend\" : \"mouseup\",\r\n\t\ttouchMoveEvent = supportTouch ? \"touchmove\" : \"mousemove\";\r\n\r\n\t// setup new event shortcuts\r\n\t$.each( ( \"touchstart touchmove touchend \" +\r\n\t\t\"tap taphold \" +\r\n\t\t\"swipe swipeleft swiperight \" +\r\n\t\t\"scrollstart scrollstop\" ).split( \" \" ), function( i, name ) {\r\n\r\n\t\t$.fn[ name ] = function( fn ) {\r\n\t\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\r\n\t\t};\r\n\r\n\t\t// jQuery < 1.8\r\n\t\tif ( $.attrFn ) {\r\n\t\t\t$.attrFn[ name ] = true;\r\n\t\t}\r\n\t});\r\n\r\n\tfunction triggerCustomEvent( obj, eventType, event, bubble ) {\r\n\t\tvar originalType = event.type;\r\n\t\tevent.type = eventType;\r\n\t\tif ( bubble ) {\r\n\t\t\t$.event.trigger( event, undefined, obj );\r\n\t\t} else {\r\n\t\t\t$.event.dispatch.call( obj, event );\r\n\t\t}\r\n\t\tevent.type = originalType;\r\n\t}\r\n\r\n\t// also handles scrollstop\r\n\t$.event.special.scrollstart = {\r\n\r\n\t\tenabled: true,\r\n\t\tsetup: function() {\r\n\r\n\t\t\tvar thisObject = this,\r\n\t\t\t\t$this = $( thisObject ),\r\n\t\t\t\tscrolling,\r\n\t\t\t\ttimer;\r\n\r\n\t\t\tfunction trigger( event, state ) {\r\n\t\t\t\tscrolling = state;\r\n\t\t\t\ttriggerCustomEvent( thisObject, scrolling ? \"scrollstart\" : \"scrollstop\", event );\r\n\t\t\t}\r\n\r\n\t\t\t// iPhone triggers scroll after a small delay; use touchmove instead\r\n\t\t\t$this.bind( scrollEvent, function( event ) {\r\n\r\n\t\t\t\tif ( !$.event.special.scrollstart.enabled ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !scrolling ) {\r\n\t\t\t\t\ttrigger( event, true );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclearTimeout( timer );\r\n\t\t\t\ttimer = setTimeout( function() {\r\n\t\t\t\t\ttrigger( event, false );\r\n\t\t\t\t}, 50 );\r\n\t\t\t});\r\n\t\t},\r\n\t\tteardown: function() {\r\n\t\t\t$( this ).unbind( scrollEvent );\r\n\t\t}\r\n\t};\r\n\r\n\t// also handles taphold\r\n\t$.event.special.tap = {\r\n\t\ttapholdThreshold: 750,\r\n\t\temitTapOnTaphold: true,\r\n\t\tsetup: function() {\r\n\t\t\tvar thisObject = this,\r\n\t\t\t\t$this = $( thisObject ),\r\n\t\t\t\tisTaphold = false;\r\n\r\n\t\t\t$this.bind( \"vmousedown\", function( event ) {\r\n\t\t\t\tisTaphold = false;\r\n\t\t\t\tif ( event.which && event.which !== 1 ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar origTarget = event.target,\r\n\t\t\t\t\ttimer;\r\n\r\n\t\t\t\tfunction clearTapTimer() {\r\n\t\t\t\t\tclearTimeout( timer );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction clearTapHandlers() {\r\n\t\t\t\t\tclearTapTimer();\r\n\r\n\t\t\t\t\t$this.unbind( \"vclick\", clickHandler )\r\n\t\t\t\t\t\t.unbind( \"vmouseup\", clearTapTimer );\r\n\t\t\t\t\t$document.unbind( \"vmousecancel\", clearTapHandlers );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction clickHandler( event ) {\r\n\t\t\t\t\tclearTapHandlers();\r\n\r\n\t\t\t\t\t// ONLY trigger a 'tap' event if the start target is\r\n\t\t\t\t\t// the same as the stop target.\r\n\t\t\t\t\tif ( !isTaphold && origTarget === event.target ) {\r\n\t\t\t\t\t\ttriggerCustomEvent( thisObject, \"tap\", event );\r\n\t\t\t\t\t} else if ( isTaphold ) {\r\n\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$this.bind( \"vmouseup\", clearTapTimer )\r\n\t\t\t\t\t.bind( \"vclick\", clickHandler );\r\n\t\t\t\t$document.bind( \"vmousecancel\", clearTapHandlers );\r\n\r\n\t\t\t\ttimer = setTimeout( function() {\r\n\t\t\t\t\tif ( !$.event.special.tap.emitTapOnTaphold ) {\r\n\t\t\t\t\t\tisTaphold = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttriggerCustomEvent( thisObject, \"taphold\", $.Event( \"taphold\", { target: origTarget } ) );\r\n\t\t\t\t}, $.event.special.tap.tapholdThreshold );\r\n\t\t\t});\r\n\t\t},\r\n\t\tteardown: function() {\r\n\t\t\t$( this ).unbind( \"vmousedown\" ).unbind( \"vclick\" ).unbind( \"vmouseup\" );\r\n\t\t\t$document.unbind( \"vmousecancel\" );\r\n\t\t}\r\n\t};\r\n\r\n\t// Also handles swipeleft, swiperight\r\n\t$.event.special.swipe = {\r\n\r\n\t\t// More than this horizontal displacement, and we will suppress scrolling.\r\n\t\tscrollSupressionThreshold: 30,\r\n\r\n\t\t// More time than this, and it isn't a swipe.\r\n\t\tdurationThreshold: 1000,\r\n\r\n\t\t// Swipe horizontal displacement must be more than this.\r\n\t\thorizontalDistanceThreshold: 30,\r\n\r\n\t\t// Swipe vertical displacement must be less than this.\r\n\t\tverticalDistanceThreshold: 30,\r\n\r\n\t\tgetLocation: function ( event ) {\r\n\t\t\tvar winPageX = window.pageXOffset,\r\n\t\t\t\twinPageY = window.pageYOffset,\r\n\t\t\t\tx = event.clientX,\r\n\t\t\t\ty = event.clientY;\r\n\r\n\t\t\tif ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||\r\n\t\t\t\tevent.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {\r\n\r\n\t\t\t\t// iOS4 clientX/clientY have the value that should have been\r\n\t\t\t\t// in pageX/pageY. While pageX/page/ have the value 0\r\n\t\t\t\tx = x - winPageX;\r\n\t\t\t\ty = y - winPageY;\r\n\t\t\t} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {\r\n\r\n\t\t\t\t// Some Android browsers have totally bogus values for clientX/Y\r\n\t\t\t\t// when scrolling/zooming a page. Detectable since clientX/clientY\r\n\t\t\t\t// should never be smaller than pageX/pageY minus page scroll\r\n\t\t\t\tx = event.pageX - winPageX;\r\n\t\t\t\ty = event.pageY - winPageY;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tstart: function( event ) {\r\n\t\t\tvar data = event.originalEvent.touches ?\r\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,\r\n\t\t\t\tlocation = $.event.special.swipe.getLocation( data );\r\n\t\t\treturn {\r\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\r\n\t\t\t\t\t\tcoords: [ location.x, location.y ],\r\n\t\t\t\t\t\torigin: $( event.target )\r\n\t\t\t\t\t};\r\n\t\t},\r\n\r\n\t\tstop: function( event ) {\r\n\t\t\tvar data = event.originalEvent.touches ?\r\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,\r\n\t\t\t\tlocation = $.event.special.swipe.getLocation( data );\r\n\t\t\treturn {\r\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\r\n\t\t\t\t\t\tcoords: [ location.x, location.y ]\r\n\t\t\t\t\t};\r\n\t\t},\r\n\r\n\t\thandleSwipe: function( start, stop, thisObject, origTarget ) {\r\n\t\t\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&\r\n\t\t\t\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&\r\n\t\t\t\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {\r\n\t\t\t\tvar direction = start.coords[0] > stop.coords[ 0 ] ? \"swipeleft\" : \"swiperight\";\r\n\r\n\t\t\t\ttriggerCustomEvent( thisObject, \"swipe\", $.Event( \"swipe\", { target: origTarget, swipestart: start, swipestop: stop }), true );\r\n\t\t\t\ttriggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\r\n\t\t},\r\n\r\n\t\t// This serves as a flag to ensure that at most one swipe event event is\r\n\t\t// in work at any given time\r\n\t\teventInProgress: false,\r\n\r\n\t\tsetup: function() {\r\n\t\t\tvar events,\r\n\t\t\t\tthisObject = this,\r\n\t\t\t\t$this = $( thisObject ),\r\n\t\t\t\tcontext = {};\r\n\r\n\t\t\t// Retrieve the events data for this element and add the swipe context\r\n\t\t\tevents = $.data( this, \"mobile-events\" );\r\n\t\t\tif ( !events ) {\r\n\t\t\t\tevents = { length: 0 };\r\n\t\t\t\t$.data( this, \"mobile-events\", events );\r\n\t\t\t}\r\n\t\t\tevents.length++;\r\n\t\t\tevents.swipe = context;\r\n\r\n\t\t\tcontext.start = function( event ) {\r\n\r\n\t\t\t\t// Bail if we're already working on a swipe event\r\n\t\t\t\tif ( $.event.special.swipe.eventInProgress ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t$.event.special.swipe.eventInProgress = true;\r\n\r\n\t\t\t\tvar stop,\r\n\t\t\t\t\tstart = $.event.special.swipe.start( event ),\r\n\t\t\t\t\torigTarget = event.target,\r\n\t\t\t\t\temitted = false;\r\n\r\n\t\t\t\tcontext.move = function( event ) {\r\n\t\t\t\t\tif ( !start || event.isDefaultPrevented() ) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstop = $.event.special.swipe.stop( event );\r\n\t\t\t\t\tif ( !emitted ) {\r\n\t\t\t\t\t\temitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );\r\n\t\t\t\t\t\tif ( emitted ) {\r\n\r\n\t\t\t\t\t\t\t// Reset the context to make way for the next swipe event\r\n\t\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// prevent scrolling\r\n\t\t\t\t\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {\r\n\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tcontext.stop = function() {\r\n\t\t\t\t\t\temitted = true;\r\n\r\n\t\t\t\t\t\t// Reset the context to make way for the next swipe event\r\n\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;\r\n\t\t\t\t\t\t$document.off( touchMoveEvent, context.move );\r\n\t\t\t\t\t\tcontext.move = null;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t$document.on( touchMoveEvent, context.move )\r\n\t\t\t\t\t.one( touchStopEvent, context.stop );\r\n\t\t\t};\r\n\t\t\t$this.on( touchStartEvent, context.start );\r\n\t\t},\r\n\r\n\t\tteardown: function() {\r\n\t\t\tvar events, context;\r\n\r\n\t\t\tevents = $.data( this, \"mobile-events\" );\r\n\t\t\tif ( events ) {\r\n\t\t\t\tcontext = events.swipe;\r\n\t\t\t\tdelete events.swipe;\r\n\t\t\t\tevents.length--;\r\n\t\t\t\tif ( events.length === 0 ) {\r\n\t\t\t\t\t$.removeData( this, \"mobile-events\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( context ) {\r\n\t\t\t\tif ( context.start ) {\r\n\t\t\t\t\t$( this ).off( touchStartEvent, context.start );\r\n\t\t\t\t}\r\n\t\t\t\tif ( context.move ) {\r\n\t\t\t\t\t$document.off( touchMoveEvent, context.move );\r\n\t\t\t\t}\r\n\t\t\t\tif ( context.stop ) {\r\n\t\t\t\t\t$document.off( touchStopEvent, context.stop );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t$.each({\r\n\t\tscrollstop: \"scrollstart\",\r\n\t\ttaphold: \"tap\",\r\n\t\tswipeleft: \"swipe.left\",\r\n\t\tswiperight: \"swipe.right\"\r\n\t}, function( event, sourceEvent ) {\r\n\r\n\t\t$.event.special[ event ] = {\r\n\t\t\tsetup: function() {\r\n\t\t\t\t$( this ).bind( sourceEvent, $.noop );\r\n\t\t\t},\r\n\t\t\tteardown: function() {\r\n\t\t\t\t$( this ).unbind( sourceEvent );\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n\r\n})( jQuery, this );\r\n\r\n\r\n}));\r\n"],"sourceRoot":"/source/"}